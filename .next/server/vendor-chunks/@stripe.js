"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@stripe";
exports.ids = ["vendor-chunks/@stripe"];
exports.modules = {

/***/ "(ssr)/./node_modules/@stripe/stripe-js/dist/pure.js":
/*!*****************************************************!*\
  !*** ./node_modules/@stripe/stripe-js/dist/pure.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function(obj) {\n            return typeof obj;\n        };\n    } else {\n        _typeof = function(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n    }\n    return _typeof(obj);\n}\nvar RELEASE_TRAIN = \"v3\";\nvar runtimeVersionToUrlVersion = function runtimeVersionToUrlVersion(version) {\n    return version === 3 ? \"v3\" : version;\n};\nvar ORIGIN = \"https://js.stripe.com\";\nvar STRIPE_JS_URL = \"\".concat(ORIGIN, \"/v3\");\nvar V3_URL_REGEX = /^https:\\/\\/js\\.stripe\\.com\\/v3\\/?(\\?.*)?$/;\nvar STRIPE_JS_URL_REGEX = /^https:\\/\\/js\\.stripe\\.com\\/(v3|[a-z]+)\\/stripe\\.js(\\?.*)?$/;\nvar EXISTING_SCRIPT_MESSAGE = \"loadStripe.setLoadParameters was called but an existing Stripe.js script already exists in the document; existing script parameters will be used\";\nvar isStripeJSURL = function isStripeJSURL(url) {\n    return V3_URL_REGEX.test(url) || STRIPE_JS_URL_REGEX.test(url);\n};\nvar findScript = function findScript() {\n    var scripts = document.querySelectorAll('script[src^=\"'.concat(ORIGIN, '\"]'));\n    for(var i = 0; i < scripts.length; i++){\n        var script = scripts[i];\n        if (!isStripeJSURL(script.src)) {\n            continue;\n        }\n        return script;\n    }\n    return null;\n};\nvar injectScript = function injectScript(params) {\n    var queryString = params && !params.advancedFraudSignals ? \"?advancedFraudSignals=false\" : \"\";\n    var script = document.createElement(\"script\");\n    script.src = \"\".concat(STRIPE_JS_URL).concat(queryString);\n    var headOrBody = document.head || document.body;\n    if (!headOrBody) {\n        throw new Error(\"Expected document.body not to be null. Stripe.js requires a <body> element.\");\n    }\n    headOrBody.appendChild(script);\n    return script;\n};\nvar registerWrapper = function registerWrapper(stripe, startTime) {\n    if (!stripe || !stripe._registerWrapper) {\n        return;\n    }\n    stripe._registerWrapper({\n        name: \"stripe-js\",\n        version: \"5.10.0\",\n        startTime: startTime\n    });\n};\nvar stripePromise = null;\nvar onErrorListener = null;\nvar onLoadListener = null;\nvar onError = function onError(reject) {\n    return function(cause) {\n        reject(new Error(\"Failed to load Stripe.js\", {\n            cause: cause\n        }));\n    };\n};\nvar onLoad = function onLoad(resolve, reject) {\n    return function() {\n        if (window.Stripe) {\n            resolve(window.Stripe);\n        } else {\n            reject(new Error(\"Stripe.js not available\"));\n        }\n    };\n};\nvar loadScript = function loadScript(params) {\n    // Ensure that we only attempt to load Stripe.js at most once\n    if (stripePromise !== null) {\n        return stripePromise;\n    }\n    stripePromise = new Promise(function(resolve, reject) {\n        if (true) {\n            // Resolve to null when imported server side. This makes the module\n            // safe to import in an isomorphic code base.\n            resolve(null);\n            return;\n        }\n        if (window.Stripe && params) {\n            console.warn(EXISTING_SCRIPT_MESSAGE);\n        }\n        if (window.Stripe) {\n            resolve(window.Stripe);\n            return;\n        }\n        try {\n            var script = findScript();\n            if (script && params) {\n                console.warn(EXISTING_SCRIPT_MESSAGE);\n            } else if (!script) {\n                script = injectScript(params);\n            } else if (script && onLoadListener !== null && onErrorListener !== null) {\n                var _script$parentNode;\n                // remove event listeners\n                script.removeEventListener(\"load\", onLoadListener);\n                script.removeEventListener(\"error\", onErrorListener); // if script exists, but we are reloading due to an error,\n                // reload script to trigger 'load' event\n                (_script$parentNode = script.parentNode) === null || _script$parentNode === void 0 ? void 0 : _script$parentNode.removeChild(script);\n                script = injectScript(params);\n            }\n            onLoadListener = onLoad(resolve, reject);\n            onErrorListener = onError(reject);\n            script.addEventListener(\"load\", onLoadListener);\n            script.addEventListener(\"error\", onErrorListener);\n        } catch (error) {\n            reject(error);\n            return;\n        }\n    }); // Resets stripePromise on error\n    return stripePromise[\"catch\"](function(error) {\n        stripePromise = null;\n        return Promise.reject(error);\n    });\n};\nvar initStripe = function initStripe(maybeStripe, args, startTime) {\n    if (maybeStripe === null) {\n        return null;\n    }\n    var pk = args[0];\n    var isTestKey = pk.match(/^pk_test/); // @ts-expect-error this is not publicly typed\n    var version = runtimeVersionToUrlVersion(maybeStripe.version);\n    var expectedVersion = RELEASE_TRAIN;\n    if (isTestKey && version !== expectedVersion) {\n        console.warn(\"Stripe.js@\".concat(version, \" was loaded on the page, but @stripe/stripe-js@\").concat(\"5.10.0\", \" expected Stripe.js@\").concat(expectedVersion, \". This may result in unexpected behavior. For more information, see https://docs.stripe.com/sdks/stripejs-versioning\"));\n    }\n    var stripe = maybeStripe.apply(undefined, args);\n    registerWrapper(stripe, startTime);\n    return stripe;\n}; // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nvar validateLoadParams = function validateLoadParams(params) {\n    var errorMessage = \"invalid load parameters; expected object of shape\\n\\n    {advancedFraudSignals: boolean}\\n\\nbut received\\n\\n    \".concat(JSON.stringify(params), \"\\n\");\n    if (params === null || _typeof(params) !== \"object\") {\n        throw new Error(errorMessage);\n    }\n    if (Object.keys(params).length === 1 && typeof params.advancedFraudSignals === \"boolean\") {\n        return params;\n    }\n    throw new Error(errorMessage);\n};\nvar loadParams;\nvar loadStripeCalled = false;\nvar loadStripe = function loadStripe() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    loadStripeCalled = true;\n    var startTime = Date.now();\n    return loadScript(loadParams).then(function(maybeStripe) {\n        return initStripe(maybeStripe, args, startTime);\n    });\n};\nloadStripe.setLoadParameters = function(params) {\n    // we won't throw an error if setLoadParameters is called with the same values as before\n    if (loadStripeCalled && loadParams) {\n        var validatedParams = validateLoadParams(params);\n        var parameterKeys = Object.keys(validatedParams);\n        var sameParameters = parameterKeys.reduce(function(previousValue, currentValue) {\n            var _loadParams;\n            return previousValue && params[currentValue] === ((_loadParams = loadParams) === null || _loadParams === void 0 ? void 0 : _loadParams[currentValue]);\n        }, true);\n        if (sameParameters) {\n            return;\n        }\n    }\n    if (loadStripeCalled) {\n        throw new Error(\"You cannot change load parameters after calling loadStripe\");\n    }\n    loadParams = validateLoadParams(params);\n};\nexports.loadStripe = loadStripe;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9zdHJpcGUtanMvZGlzdC9wdXJlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELFNBQVNDLFFBQVFDLEdBQUc7SUFDbEI7SUFFQSxJQUFJLE9BQU9DLFdBQVcsY0FBYyxPQUFPQSxPQUFPQyxRQUFRLEtBQUssVUFBVTtRQUN2RUgsVUFBVSxTQUFVQyxHQUFHO1lBQ3JCLE9BQU8sT0FBT0E7UUFDaEI7SUFDRixPQUFPO1FBQ0xELFVBQVUsU0FBVUMsR0FBRztZQUNyQixPQUFPQSxPQUFPLE9BQU9DLFdBQVcsY0FBY0QsSUFBSUcsV0FBVyxLQUFLRixVQUFVRCxRQUFRQyxPQUFPRyxTQUFTLEdBQUcsV0FBVyxPQUFPSjtRQUMzSDtJQUNGO0lBRUEsT0FBT0QsUUFBUUM7QUFDakI7QUFFQSxJQUFJSyxnQkFBZ0I7QUFFcEIsSUFBSUMsNkJBQTZCLFNBQVNBLDJCQUEyQkMsT0FBTztJQUMxRSxPQUFPQSxZQUFZLElBQUksT0FBT0E7QUFDaEM7QUFFQSxJQUFJQyxTQUFTO0FBQ2IsSUFBSUMsZ0JBQWdCLEdBQUdDLE1BQU0sQ0FBQ0YsUUFBUTtBQUN0QyxJQUFJRyxlQUFlO0FBQ25CLElBQUlDLHNCQUFzQjtBQUMxQixJQUFJQywwQkFBMEI7QUFFOUIsSUFBSUMsZ0JBQWdCLFNBQVNBLGNBQWNDLEdBQUc7SUFDNUMsT0FBT0osYUFBYUssSUFBSSxDQUFDRCxRQUFRSCxvQkFBb0JJLElBQUksQ0FBQ0Q7QUFDNUQ7QUFFQSxJQUFJRSxhQUFhLFNBQVNBO0lBQ3hCLElBQUlDLFVBQVVDLFNBQVNDLGdCQUFnQixDQUFDLGdCQUFpQlYsTUFBTSxDQUFDRixRQUFRO0lBRXhFLElBQUssSUFBSWEsSUFBSSxHQUFHQSxJQUFJSCxRQUFRSSxNQUFNLEVBQUVELElBQUs7UUFDdkMsSUFBSUUsU0FBU0wsT0FBTyxDQUFDRyxFQUFFO1FBRXZCLElBQUksQ0FBQ1As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QUN2QixJQUFJQyxhQUFhLFNBQVNBO0lBQ3hCLElBQUssSUFBSUMsT0FBT0MsVUFBVXhELE1BQU0sRUFBRXdDLE9BQU8sSUFBSWlCLE1BQU1GLE9BQU9HLE9BQU8sR0FBR0EsT0FBT0gsTUFBTUcsT0FBUTtRQUN2RmxCLElBQUksQ0FBQ2tCLEtBQUssR0FBR0YsU0FBUyxDQUFDRSxLQUFLO0lBQzlCO0lBRUFMLG1CQUFtQjtJQUNuQixJQUFJdEMsWUFBWTRDLEtBQUtDLEdBQUc7SUFDeEIsT0FBT2hDLFdBQVd3QixZQUFZUyxJQUFJLENBQUMsU0FBVXRCLFdBQVc7UUFDdEQsT0FBT0QsV0FBV0MsYUFBYUMsTUFBTXpCO0lBQ3ZDO0FBQ0Y7QUFFQXVDLFdBQVdRLGlCQUFpQixHQUFHLFNBQVUxRCxNQUFNO0lBQzdDLHdGQUF3RjtJQUN4RixJQUFJaUQsb0JBQW9CRCxZQUFZO1FBQ2xDLElBQUlXLGtCQUFrQmhCLG1CQUFtQjNDO1FBQ3pDLElBQUk0RCxnQkFBZ0IzRixPQUFPOEUsSUFBSSxDQUFDWTtRQUNoQyxJQUFJRSxpQkFBaUJELGNBQWNFLE1BQU0sQ0FBQyxTQUFVQyxhQUFhLEVBQUVDLFlBQVk7WUFDN0UsSUFBSUM7WUFFSixPQUFPRixpQkFBaUIvRCxNQUFNLENBQUNnRSxhQUFhLEtBQU0sRUFBQ0MsY0FBY2pCLFVBQVMsTUFBTyxRQUFRaUIsZ0JBQWdCLEtBQUssSUFBSSxLQUFLLElBQUlBLFdBQVcsQ0FBQ0QsYUFBYTtRQUN0SixHQUFHO1FBRUgsSUFBSUgsZ0JBQWdCO1lBQ2xCO1FBQ0Y7SUFDRjtJQUVBLElBQUlaLGtCQUFrQjtRQUNwQixNQUFNLElBQUkxQyxNQUFNO0lBQ2xCO0lBRUF5QyxhQUFhTCxtQkFBbUIzQztBQUNsQztBQUVBN0Isa0JBQWtCLEdBQUcrRSIsInNvdXJjZXMiOlsid2VicGFjazovL25vZmFwLWFwcC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL0BzdHJpcGUvc3RyaXBlLWpzL2Rpc3QvcHVyZS5qcz85NzUwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxudmFyIFJFTEVBU0VfVFJBSU4gPSAndjMnO1xuXG52YXIgcnVudGltZVZlcnNpb25Ub1VybFZlcnNpb24gPSBmdW5jdGlvbiBydW50aW1lVmVyc2lvblRvVXJsVmVyc2lvbih2ZXJzaW9uKSB7XG4gIHJldHVybiB2ZXJzaW9uID09PSAzID8gJ3YzJyA6IHZlcnNpb247XG59O1xuXG52YXIgT1JJR0lOID0gJ2h0dHBzOi8vanMuc3RyaXBlLmNvbSc7XG52YXIgU1RSSVBFX0pTX1VSTCA9IFwiXCIuY29uY2F0KE9SSUdJTiwgXCIvdjNcIikgO1xudmFyIFYzX1VSTF9SRUdFWCA9IC9eaHR0cHM6XFwvXFwvanNcXC5zdHJpcGVcXC5jb21cXC92M1xcLz8oXFw/LiopPyQvO1xudmFyIFNUUklQRV9KU19VUkxfUkVHRVggPSAvXmh0dHBzOlxcL1xcL2pzXFwuc3RyaXBlXFwuY29tXFwvKHYzfFthLXpdKylcXC9zdHJpcGVcXC5qcyhcXD8uKik/JC87XG52YXIgRVhJU1RJTkdfU0NSSVBUX01FU1NBR0UgPSAnbG9hZFN0cmlwZS5zZXRMb2FkUGFyYW1ldGVycyB3YXMgY2FsbGVkIGJ1dCBhbiBleGlzdGluZyBTdHJpcGUuanMgc2NyaXB0IGFscmVhZHkgZXhpc3RzIGluIHRoZSBkb2N1bWVudDsgZXhpc3Rpbmcgc2NyaXB0IHBhcmFtZXRlcnMgd2lsbCBiZSB1c2VkJztcblxudmFyIGlzU3RyaXBlSlNVUkwgPSBmdW5jdGlvbiBpc1N0cmlwZUpTVVJMKHVybCkge1xuICByZXR1cm4gVjNfVVJMX1JFR0VYLnRlc3QodXJsKSB8fCBTVFJJUEVfSlNfVVJMX1JFR0VYLnRlc3QodXJsKTtcbn07XG5cbnZhciBmaW5kU2NyaXB0ID0gZnVuY3Rpb24gZmluZFNjcmlwdCgpIHtcbiAgdmFyIHNjcmlwdHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwic2NyaXB0W3NyY149XFxcIlwiLmNvbmNhdChPUklHSU4sIFwiXFxcIl1cIikpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2NyaXB0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzY3JpcHQgPSBzY3JpcHRzW2ldO1xuXG4gICAgaWYgKCFpc1N0cmlwZUpTVVJMKHNjcmlwdC5zcmMpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2NyaXB0O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG52YXIgaW5qZWN0U2NyaXB0ID0gZnVuY3Rpb24gaW5qZWN0U2NyaXB0KHBhcmFtcykge1xuICB2YXIgcXVlcnlTdHJpbmcgPSBwYXJhbXMgJiYgIXBhcmFtcy5hZHZhbmNlZEZyYXVkU2lnbmFscyA/ICc/YWR2YW5jZWRGcmF1ZFNpZ25hbHM9ZmFsc2UnIDogJyc7XG4gIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgc2NyaXB0LnNyYyA9IFwiXCIuY29uY2F0KFNUUklQRV9KU19VUkwpLmNvbmNhdChxdWVyeVN0cmluZyk7XG4gIHZhciBoZWFkT3JCb2R5ID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5O1xuXG4gIGlmICghaGVhZE9yQm9keSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZG9jdW1lbnQuYm9keSBub3QgdG8gYmUgbnVsbC4gU3RyaXBlLmpzIHJlcXVpcmVzIGEgPGJvZHk+IGVsZW1lbnQuJyk7XG4gIH1cblxuICBoZWFkT3JCb2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gIHJldHVybiBzY3JpcHQ7XG59O1xuXG52YXIgcmVnaXN0ZXJXcmFwcGVyID0gZnVuY3Rpb24gcmVnaXN0ZXJXcmFwcGVyKHN0cmlwZSwgc3RhcnRUaW1lKSB7XG4gIGlmICghc3RyaXBlIHx8ICFzdHJpcGUuX3JlZ2lzdGVyV3JhcHBlcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0cmlwZS5fcmVnaXN0ZXJXcmFwcGVyKHtcbiAgICBuYW1lOiAnc3RyaXBlLWpzJyxcbiAgICB2ZXJzaW9uOiBcIjUuMTAuMFwiLFxuICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lXG4gIH0pO1xufTtcblxudmFyIHN0cmlwZVByb21pc2UgPSBudWxsO1xudmFyIG9uRXJyb3JMaXN0ZW5lciA9IG51bGw7XG52YXIgb25Mb2FkTGlzdGVuZXIgPSBudWxsO1xuXG52YXIgb25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IocmVqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoY2F1c2UpIHtcbiAgICByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBTdHJpcGUuanMnLCB7XG4gICAgICBjYXVzZTogY2F1c2VcbiAgICB9KSk7XG4gIH07XG59O1xuXG52YXIgb25Mb2FkID0gZnVuY3Rpb24gb25Mb2FkKHJlc29sdmUsIHJlamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICh3aW5kb3cuU3RyaXBlKSB7XG4gICAgICByZXNvbHZlKHdpbmRvdy5TdHJpcGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWplY3QobmV3IEVycm9yKCdTdHJpcGUuanMgbm90IGF2YWlsYWJsZScpKTtcbiAgICB9XG4gIH07XG59O1xuXG52YXIgbG9hZFNjcmlwdCA9IGZ1bmN0aW9uIGxvYWRTY3JpcHQocGFyYW1zKSB7XG4gIC8vIEVuc3VyZSB0aGF0IHdlIG9ubHkgYXR0ZW1wdCB0byBsb2FkIFN0cmlwZS5qcyBhdCBtb3N0IG9uY2VcbiAgaWYgKHN0cmlwZVByb21pc2UgIT09IG51bGwpIHtcbiAgICByZXR1cm4gc3RyaXBlUHJvbWlzZTtcbiAgfVxuXG4gIHN0cmlwZVByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFJlc29sdmUgdG8gbnVsbCB3aGVuIGltcG9ydGVkIHNlcnZlciBzaWRlLiBUaGlzIG1ha2VzIHRoZSBtb2R1bGVcbiAgICAgIC8vIHNhZmUgdG8gaW1wb3J0IGluIGFuIGlzb21vcnBoaWMgY29kZSBiYXNlLlxuICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAod2luZG93LlN0cmlwZSAmJiBwYXJhbXMpIHtcbiAgICAgIGNvbnNvbGUud2FybihFWElTVElOR19TQ1JJUFRfTUVTU0FHRSk7XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdy5TdHJpcGUpIHtcbiAgICAgIHJlc29sdmUod2luZG93LlN0cmlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBzY3JpcHQgPSBmaW5kU2NyaXB0KCk7XG5cbiAgICAgIGlmIChzY3JpcHQgJiYgcGFyYW1zKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihFWElTVElOR19TQ1JJUFRfTUVTU0FHRSk7XG4gICAgICB9IGVsc2UgaWYgKCFzY3JpcHQpIHtcbiAgICAgICAgc2NyaXB0ID0gaW5qZWN0U2NyaXB0KHBhcmFtcyk7XG4gICAgICB9IGVsc2UgaWYgKHNjcmlwdCAmJiBvbkxvYWRMaXN0ZW5lciAhPT0gbnVsbCAmJiBvbkVycm9yTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIF9zY3JpcHQkcGFyZW50Tm9kZTtcblxuICAgICAgICAvLyByZW1vdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIHNjcmlwdC5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkTGlzdGVuZXIpO1xuICAgICAgICBzY3JpcHQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yTGlzdGVuZXIpOyAvLyBpZiBzY3JpcHQgZXhpc3RzLCBidXQgd2UgYXJlIHJlbG9hZGluZyBkdWUgdG8gYW4gZXJyb3IsXG4gICAgICAgIC8vIHJlbG9hZCBzY3JpcHQgdG8gdHJpZ2dlciAnbG9hZCcgZXZlbnRcblxuICAgICAgICAoX3NjcmlwdCRwYXJlbnROb2RlID0gc2NyaXB0LnBhcmVudE5vZGUpID09PSBudWxsIHx8IF9zY3JpcHQkcGFyZW50Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NjcmlwdCRwYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgIHNjcmlwdCA9IGluamVjdFNjcmlwdChwYXJhbXMpO1xuICAgICAgfVxuXG4gICAgICBvbkxvYWRMaXN0ZW5lciA9IG9uTG9hZChyZXNvbHZlLCByZWplY3QpO1xuICAgICAgb25FcnJvckxpc3RlbmVyID0gb25FcnJvcihyZWplY3QpO1xuICAgICAgc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWRMaXN0ZW5lcik7XG4gICAgICBzY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yTGlzdGVuZXIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSk7IC8vIFJlc2V0cyBzdHJpcGVQcm9taXNlIG9uIGVycm9yXG5cbiAgcmV0dXJuIHN0cmlwZVByb21pc2VbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBzdHJpcGVQcm9taXNlID0gbnVsbDtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICB9KTtcbn07XG52YXIgaW5pdFN0cmlwZSA9IGZ1bmN0aW9uIGluaXRTdHJpcGUobWF5YmVTdHJpcGUsIGFyZ3MsIHN0YXJ0VGltZSkge1xuICBpZiAobWF5YmVTdHJpcGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBwayA9IGFyZ3NbMF07XG4gIHZhciBpc1Rlc3RLZXkgPSBway5tYXRjaCgvXnBrX3Rlc3QvKTsgLy8gQHRzLWV4cGVjdC1lcnJvciB0aGlzIGlzIG5vdCBwdWJsaWNseSB0eXBlZFxuXG4gIHZhciB2ZXJzaW9uID0gcnVudGltZVZlcnNpb25Ub1VybFZlcnNpb24obWF5YmVTdHJpcGUudmVyc2lvbik7XG4gIHZhciBleHBlY3RlZFZlcnNpb24gPSBSRUxFQVNFX1RSQUlOO1xuXG4gIGlmIChpc1Rlc3RLZXkgJiYgdmVyc2lvbiAhPT0gZXhwZWN0ZWRWZXJzaW9uKSB7XG4gICAgY29uc29sZS53YXJuKFwiU3RyaXBlLmpzQFwiLmNvbmNhdCh2ZXJzaW9uLCBcIiB3YXMgbG9hZGVkIG9uIHRoZSBwYWdlLCBidXQgQHN0cmlwZS9zdHJpcGUtanNAXCIpLmNvbmNhdChcIjUuMTAuMFwiLCBcIiBleHBlY3RlZCBTdHJpcGUuanNAXCIpLmNvbmNhdChleHBlY3RlZFZlcnNpb24sIFwiLiBUaGlzIG1heSByZXN1bHQgaW4gdW5leHBlY3RlZCBiZWhhdmlvci4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSBodHRwczovL2RvY3Muc3RyaXBlLmNvbS9zZGtzL3N0cmlwZWpzLXZlcnNpb25pbmdcIikpO1xuICB9XG5cbiAgdmFyIHN0cmlwZSA9IG1heWJlU3RyaXBlLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gIHJlZ2lzdGVyV3JhcHBlcihzdHJpcGUsIHN0YXJ0VGltZSk7XG4gIHJldHVybiBzdHJpcGU7XG59OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuXG52YXIgdmFsaWRhdGVMb2FkUGFyYW1zID0gZnVuY3Rpb24gdmFsaWRhdGVMb2FkUGFyYW1zKHBhcmFtcykge1xuICB2YXIgZXJyb3JNZXNzYWdlID0gXCJpbnZhbGlkIGxvYWQgcGFyYW1ldGVyczsgZXhwZWN0ZWQgb2JqZWN0IG9mIHNoYXBlXFxuXFxuICAgIHthZHZhbmNlZEZyYXVkU2lnbmFsczogYm9vbGVhbn1cXG5cXG5idXQgcmVjZWl2ZWRcXG5cXG4gICAgXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KHBhcmFtcyksIFwiXFxuXCIpO1xuXG4gIGlmIChwYXJhbXMgPT09IG51bGwgfHwgX3R5cGVvZihwYXJhbXMpICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID09PSAxICYmIHR5cGVvZiBwYXJhbXMuYWR2YW5jZWRGcmF1ZFNpZ25hbHMgPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbn07XG5cbnZhciBsb2FkUGFyYW1zO1xudmFyIGxvYWRTdHJpcGVDYWxsZWQgPSBmYWxzZTtcbnZhciBsb2FkU3RyaXBlID0gZnVuY3Rpb24gbG9hZFN0cmlwZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGxvYWRTdHJpcGVDYWxsZWQgPSB0cnVlO1xuICB2YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgcmV0dXJuIGxvYWRTY3JpcHQobG9hZFBhcmFtcykudGhlbihmdW5jdGlvbiAobWF5YmVTdHJpcGUpIHtcbiAgICByZXR1cm4gaW5pdFN0cmlwZShtYXliZVN0cmlwZSwgYXJncywgc3RhcnRUaW1lKTtcbiAgfSk7XG59O1xuXG5sb2FkU3RyaXBlLnNldExvYWRQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAvLyB3ZSB3b24ndCB0aHJvdyBhbiBlcnJvciBpZiBzZXRMb2FkUGFyYW1ldGVycyBpcyBjYWxsZWQgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgYmVmb3JlXG4gIGlmIChsb2FkU3RyaXBlQ2FsbGVkICYmIGxvYWRQYXJhbXMpIHtcbiAgICB2YXIgdmFsaWRhdGVkUGFyYW1zID0gdmFsaWRhdGVMb2FkUGFyYW1zKHBhcmFtcyk7XG4gICAgdmFyIHBhcmFtZXRlcktleXMgPSBPYmplY3Qua2V5cyh2YWxpZGF0ZWRQYXJhbXMpO1xuICAgIHZhciBzYW1lUGFyYW1ldGVycyA9IHBhcmFtZXRlcktleXMucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUpIHtcbiAgICAgIHZhciBfbG9hZFBhcmFtcztcblxuICAgICAgcmV0dXJuIHByZXZpb3VzVmFsdWUgJiYgcGFyYW1zW2N1cnJlbnRWYWx1ZV0gPT09ICgoX2xvYWRQYXJhbXMgPSBsb2FkUGFyYW1zKSA9PT0gbnVsbCB8fCBfbG9hZFBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2xvYWRQYXJhbXNbY3VycmVudFZhbHVlXSk7XG4gICAgfSwgdHJ1ZSk7XG5cbiAgICBpZiAoc2FtZVBhcmFtZXRlcnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAobG9hZFN0cmlwZUNhbGxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCBjaGFuZ2UgbG9hZCBwYXJhbWV0ZXJzIGFmdGVyIGNhbGxpbmcgbG9hZFN0cmlwZScpO1xuICB9XG5cbiAgbG9hZFBhcmFtcyA9IHZhbGlkYXRlTG9hZFBhcmFtcyhwYXJhbXMpO1xufTtcblxuZXhwb3J0cy5sb2FkU3RyaXBlID0gbG9hZFN0cmlwZTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIl90eXBlb2YiLCJvYmoiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiUkVMRUFTRV9UUkFJTiIsInJ1bnRpbWVWZXJzaW9uVG9VcmxWZXJzaW9uIiwidmVyc2lvbiIsIk9SSUdJTiIsIlNUUklQRV9KU19VUkwiLCJjb25jYXQiLCJWM19VUkxfUkVHRVgiLCJTVFJJUEVfSlNfVVJMX1JFR0VYIiwiRVhJU1RJTkdfU0NSSVBUX01FU1NBR0UiLCJpc1N0cmlwZUpTVVJMIiwidXJsIiwidGVzdCIsImZpbmRTY3JpcHQiLCJzY3JpcHRzIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaSIsImxlbmd0aCIsInNjcmlwdCIsInNyYyIsImluamVjdFNjcmlwdCIsInBhcmFtcyIsInF1ZXJ5U3RyaW5nIiwiYWR2YW5jZWRGcmF1ZFNpZ25hbHMiLCJjcmVhdGVFbGVtZW50IiwiaGVhZE9yQm9keSIsImhlYWQiLCJib2R5IiwiRXJyb3IiLCJhcHBlbmRDaGlsZCIsInJlZ2lzdGVyV3JhcHBlciIsInN0cmlwZSIsInN0YXJ0VGltZSIsIl9yZWdpc3RlcldyYXBwZXIiLCJuYW1lIiwic3RyaXBlUHJvbWlzZSIsIm9uRXJyb3JMaXN0ZW5lciIsIm9uTG9hZExpc3RlbmVyIiwib25FcnJvciIsInJlamVjdCIsImNhdXNlIiwib25Mb2FkIiwicmVzb2x2ZSIsIndpbmRvdyIsIlN0cmlwZSIsImxvYWRTY3JpcHQiLCJQcm9taXNlIiwiY29uc29sZSIsIndhcm4iLCJfc2NyaXB0JHBhcmVudE5vZGUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiYWRkRXZlbnRMaXN0ZW5lciIsImVycm9yIiwiaW5pdFN0cmlwZSIsIm1heWJlU3RyaXBlIiwiYXJncyIsInBrIiwiaXNUZXN0S2V5IiwibWF0Y2giLCJleHBlY3RlZFZlcnNpb24iLCJhcHBseSIsInVuZGVmaW5lZCIsInZhbGlkYXRlTG9hZFBhcmFtcyIsImVycm9yTWVzc2FnZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJrZXlzIiwibG9hZFBhcmFtcyIsImxvYWRTdHJpcGVDYWxsZWQiLCJsb2FkU3RyaXBlIiwiX2xlbiIsImFyZ3VtZW50cyIsIkFycmF5IiwiX2tleSIsIkRhdGUiLCJub3ciLCJ0aGVuIiwic2V0TG9hZFBhcmFtZXRlcnMiLCJ2YWxpZGF0ZWRQYXJhbXMiLCJwYXJhbWV0ZXJLZXlzIiwic2FtZVBhcmFtZXRlcnMiLCJyZWR1Y2UiLCJwcmV2aW91c1ZhbHVlIiwiY3VycmVudFZhbHVlIiwiX2xvYWRQYXJhbXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/stripe-js/dist/pure.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stripe/stripe-js/pure/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@stripe/stripe-js/pure/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = __webpack_require__(/*! ../dist/pure */ \"(ssr)/./node_modules/@stripe/stripe-js/dist/pure.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9zdHJpcGUtanMvcHVyZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQUFBLCtHQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL25vZmFwLWFwcC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL0BzdHJpcGUvc3RyaXBlLWpzL3B1cmUvaW5kZXguanM/ZDc3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Rpc3QvcHVyZScpO1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/stripe-js/pure/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stripe/react-stripe-js/dist/react-stripe.esm.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@stripe/react-stripe-js/dist/react-stripe.esm.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressElement: () => (/* binding */ AddressElement),\n/* harmony export */   AffirmMessageElement: () => (/* binding */ AffirmMessageElement),\n/* harmony export */   AfterpayClearpayMessageElement: () => (/* binding */ AfterpayClearpayMessageElement),\n/* harmony export */   AuBankAccountElement: () => (/* binding */ AuBankAccountElement),\n/* harmony export */   CardCvcElement: () => (/* binding */ CardCvcElement),\n/* harmony export */   CardElement: () => (/* binding */ CardElement),\n/* harmony export */   CardExpiryElement: () => (/* binding */ CardExpiryElement),\n/* harmony export */   CardNumberElement: () => (/* binding */ CardNumberElement),\n/* harmony export */   CheckoutProvider: () => (/* binding */ CheckoutProvider),\n/* harmony export */   CurrencySelectorElement: () => (/* binding */ CurrencySelectorElement),\n/* harmony export */   Elements: () => (/* binding */ Elements),\n/* harmony export */   ElementsConsumer: () => (/* binding */ ElementsConsumer),\n/* harmony export */   EmbeddedCheckout: () => (/* binding */ EmbeddedCheckout),\n/* harmony export */   EmbeddedCheckoutProvider: () => (/* binding */ EmbeddedCheckoutProvider),\n/* harmony export */   EpsBankElement: () => (/* binding */ EpsBankElement),\n/* harmony export */   ExpressCheckoutElement: () => (/* binding */ ExpressCheckoutElement),\n/* harmony export */   FpxBankElement: () => (/* binding */ FpxBankElement),\n/* harmony export */   IbanElement: () => (/* binding */ IbanElement),\n/* harmony export */   IdealBankElement: () => (/* binding */ IdealBankElement),\n/* harmony export */   LinkAuthenticationElement: () => (/* binding */ LinkAuthenticationElement),\n/* harmony export */   P24BankElement: () => (/* binding */ P24BankElement),\n/* harmony export */   PaymentElement: () => (/* binding */ PaymentElement),\n/* harmony export */   PaymentMethodMessagingElement: () => (/* binding */ PaymentMethodMessagingElement),\n/* harmony export */   PaymentRequestButtonElement: () => (/* binding */ PaymentRequestButtonElement),\n/* harmony export */   ShippingAddressElement: () => (/* binding */ ShippingAddressElement),\n/* harmony export */   useCheckout: () => (/* binding */ useCheckout),\n/* harmony export */   useElements: () => (/* binding */ useElements),\n/* harmony export */   useStripe: () => (/* binding */ useStripe)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\n\n\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function(obj) {\n            return typeof obj;\n        };\n    } else {\n        _typeof = function(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n    }\n    return _typeof(obj);\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar useAttachEvent = function useAttachEvent(element, event, cb) {\n    var cbDefined = !!cb;\n    var cbRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(cb); // In many integrations the callback prop changes on each render.\n    // Using a ref saves us from calling element.on/.off every render.\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        cbRef.current = cb;\n    }, [\n        cb\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        if (!cbDefined || !element) {\n            return function() {};\n        }\n        var decoratedCb = function decoratedCb() {\n            if (cbRef.current) {\n                cbRef.current.apply(cbRef, arguments);\n            }\n        };\n        element.on(event, decoratedCb);\n        return function() {\n            element.off(event, decoratedCb);\n        };\n    }, [\n        cbDefined,\n        event,\n        element,\n        cbRef\n    ]);\n};\nvar usePrevious = function usePrevious(value) {\n    var ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(value);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        ref.current = value;\n    }, [\n        value\n    ]);\n    return ref.current;\n};\nvar isUnknownObject = function isUnknownObject(raw) {\n    return raw !== null && _typeof(raw) === \"object\";\n};\nvar isPromise = function isPromise(raw) {\n    return isUnknownObject(raw) && typeof raw.then === \"function\";\n}; // We are using types to enforce the `stripe` prop in this lib,\n// but in an untyped integration `stripe` could be anything, so we need\n// to do some sanity validation to prevent type errors.\nvar isStripe = function isStripe(raw) {\n    return isUnknownObject(raw) && typeof raw.elements === \"function\" && typeof raw.createToken === \"function\" && typeof raw.createPaymentMethod === \"function\" && typeof raw.confirmCardPayment === \"function\";\n};\nvar PLAIN_OBJECT_STR = \"[object Object]\";\nvar isEqual = function isEqual(left, right) {\n    if (!isUnknownObject(left) || !isUnknownObject(right)) {\n        return left === right;\n    }\n    var leftArray = Array.isArray(left);\n    var rightArray = Array.isArray(right);\n    if (leftArray !== rightArray) return false;\n    var leftPlainObject = Object.prototype.toString.call(left) === PLAIN_OBJECT_STR;\n    var rightPlainObject = Object.prototype.toString.call(right) === PLAIN_OBJECT_STR;\n    if (leftPlainObject !== rightPlainObject) return false; // not sure what sort of special object this is (regexp is one option), so\n    // fallback to reference check.\n    if (!leftPlainObject && !leftArray) return left === right;\n    var leftKeys = Object.keys(left);\n    var rightKeys = Object.keys(right);\n    if (leftKeys.length !== rightKeys.length) return false;\n    var keySet = {};\n    for(var i = 0; i < leftKeys.length; i += 1){\n        keySet[leftKeys[i]] = true;\n    }\n    for(var _i = 0; _i < rightKeys.length; _i += 1){\n        keySet[rightKeys[_i]] = true;\n    }\n    var allKeys = Object.keys(keySet);\n    if (allKeys.length !== leftKeys.length) {\n        return false;\n    }\n    var l = left;\n    var r = right;\n    var pred = function pred(key) {\n        return isEqual(l[key], r[key]);\n    };\n    return allKeys.every(pred);\n};\nvar extractAllowedOptionsUpdates = function extractAllowedOptionsUpdates(options, prevOptions, immutableKeys) {\n    if (!isUnknownObject(options)) {\n        return null;\n    }\n    return Object.keys(options).reduce(function(newOptions, key) {\n        var isUpdated = !isUnknownObject(prevOptions) || !isEqual(options[key], prevOptions[key]);\n        if (immutableKeys.includes(key)) {\n            if (isUpdated) {\n                console.warn(\"Unsupported prop change: options.\".concat(key, \" is not a mutable property.\"));\n            }\n            return newOptions;\n        }\n        if (!isUpdated) {\n            return newOptions;\n        }\n        return _objectSpread2(_objectSpread2({}, newOptions || {}), {}, _defineProperty({}, key, options[key]));\n    }, null);\n};\nvar INVALID_STRIPE_ERROR$2 = \"Invalid prop `stripe` supplied to `Elements`. We recommend using the `loadStripe` utility from `@stripe/stripe-js`. See https://stripe.com/docs/stripe-js/react#elements-props-stripe for details.\"; // We are using types to enforce the `stripe` prop in this lib, but in a real\n// integration `stripe` could be anything, so we need to do some sanity\n// validation to prevent type errors.\nvar validateStripe = function validateStripe(maybeStripe) {\n    var errorMsg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : INVALID_STRIPE_ERROR$2;\n    if (maybeStripe === null || isStripe(maybeStripe)) {\n        return maybeStripe;\n    }\n    throw new Error(errorMsg);\n};\nvar parseStripeProp = function parseStripeProp(raw) {\n    var errorMsg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : INVALID_STRIPE_ERROR$2;\n    if (isPromise(raw)) {\n        return {\n            tag: \"async\",\n            stripePromise: Promise.resolve(raw).then(function(result) {\n                return validateStripe(result, errorMsg);\n            })\n        };\n    }\n    var stripe = validateStripe(raw, errorMsg);\n    if (stripe === null) {\n        return {\n            tag: \"empty\"\n        };\n    }\n    return {\n        tag: \"sync\",\n        stripe: stripe\n    };\n};\nvar registerWithStripeJs = function registerWithStripeJs(stripe) {\n    if (!stripe || !stripe._registerWrapper || !stripe.registerAppInfo) {\n        return;\n    }\n    stripe._registerWrapper({\n        name: \"react-stripe-js\",\n        version: \"3.6.0\"\n    });\n    stripe.registerAppInfo({\n        name: \"react-stripe-js\",\n        version: \"3.6.0\",\n        url: \"https://stripe.com/docs/stripe-js/react\"\n    });\n};\nvar ElementsContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nElementsContext.displayName = \"ElementsContext\";\nvar parseElementsContext = function parseElementsContext(ctx, useCase) {\n    if (!ctx) {\n        throw new Error(\"Could not find Elements context; You need to wrap the part of your app that \".concat(useCase, \" in an <Elements> provider.\"));\n    }\n    return ctx;\n};\n/**\n * The `Elements` provider allows you to use [Element components](https://stripe.com/docs/stripe-js/react#element-components) and access the [Stripe object](https://stripe.com/docs/js/initializing) in any nested component.\n * Render an `Elements` provider at the root of your React app so that it is available everywhere you need it.\n *\n * To use the `Elements` provider, call `loadStripe` from `@stripe/stripe-js` with your publishable key.\n * The `loadStripe` function will asynchronously load the Stripe.js script and initialize a `Stripe` object.\n * Pass the returned `Promise` to `Elements`.\n *\n * @docs https://stripe.com/docs/stripe-js/react#elements-provider\n */ var Elements = function Elements(_ref) {\n    var rawStripeProp = _ref.stripe, options = _ref.options, children = _ref.children;\n    var parsed = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function() {\n        return parseStripeProp(rawStripeProp);\n    }, [\n        rawStripeProp\n    ]); // For a sync stripe instance, initialize into context\n    var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(function() {\n        return {\n            stripe: parsed.tag === \"sync\" ? parsed.stripe : null,\n            elements: parsed.tag === \"sync\" ? parsed.stripe.elements(options) : null\n        };\n    }), _React$useState2 = _slicedToArray(_React$useState, 2), ctx = _React$useState2[0], setContext = _React$useState2[1];\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        var isMounted = true;\n        var safeSetContext = function safeSetContext(stripe) {\n            setContext(function(ctx) {\n                // no-op if we already have a stripe instance (https://github.com/stripe/react-stripe-js/issues/296)\n                if (ctx.stripe) return ctx;\n                return {\n                    stripe: stripe,\n                    elements: stripe.elements(options)\n                };\n            });\n        }; // For an async stripePromise, store it in context once resolved\n        if (parsed.tag === \"async\" && !ctx.stripe) {\n            parsed.stripePromise.then(function(stripe) {\n                if (stripe && isMounted) {\n                    // Only update Elements context if the component is still mounted\n                    // and stripe is not null. We allow stripe to be null to make\n                    // handling SSR easier.\n                    safeSetContext(stripe);\n                }\n            });\n        } else if (parsed.tag === \"sync\" && !ctx.stripe) {\n            // Or, handle a sync stripe instance going from null -> populated\n            safeSetContext(parsed.stripe);\n        }\n        return function() {\n            isMounted = false;\n        };\n    }, [\n        parsed,\n        ctx,\n        options\n    ]); // Warn on changes to stripe prop\n    var prevStripe = usePrevious(rawStripeProp);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        if (prevStripe !== null && prevStripe !== rawStripeProp) {\n            console.warn(\"Unsupported prop change on Elements: You cannot change the `stripe` prop after setting it.\");\n        }\n    }, [\n        prevStripe,\n        rawStripeProp\n    ]); // Apply updates to elements when options prop has relevant changes\n    var prevOptions = usePrevious(options);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        if (!ctx.elements) {\n            return;\n        }\n        var updates = extractAllowedOptionsUpdates(options, prevOptions, [\n            \"clientSecret\",\n            \"fonts\"\n        ]);\n        if (updates) {\n            ctx.elements.update(updates);\n        }\n    }, [\n        options,\n        prevOptions,\n        ctx.elements\n    ]); // Attach react-stripe-js version to stripe.js instance\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        registerWithStripeJs(ctx.stripe);\n    }, [\n        ctx.stripe\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ElementsContext.Provider, {\n        value: ctx\n    }, children);\n};\nElements.propTypes = {\n    stripe: prop_types__WEBPACK_IMPORTED_MODULE_1__.any,\n    options: prop_types__WEBPACK_IMPORTED_MODULE_1__.object\n};\nvar useElementsContextWithUseCase = function useElementsContextWithUseCase(useCaseMessage) {\n    var ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ElementsContext);\n    return parseElementsContext(ctx, useCaseMessage);\n};\n/**\n * @docs https://stripe.com/docs/stripe-js/react#useelements-hook\n */ var useElements = function useElements() {\n    var _useElementsContextWi = useElementsContextWithUseCase(\"calls useElements()\"), elements = _useElementsContextWi.elements;\n    return elements;\n};\n/**\n * @docs https://stripe.com/docs/stripe-js/react#elements-consumer\n */ var ElementsConsumer = function ElementsConsumer(_ref2) {\n    var children = _ref2.children;\n    var ctx = useElementsContextWithUseCase(\"mounts <ElementsConsumer>\"); // Assert to satisfy the busted React.FC return type (it should be ReactNode)\n    return children(ctx);\n};\nElementsConsumer.propTypes = {\n    children: prop_types__WEBPACK_IMPORTED_MODULE_1__.func.isRequired\n};\nvar _excluded$1 = [\n    \"on\",\n    \"session\"\n];\nvar CheckoutSdkContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nCheckoutSdkContext.displayName = \"CheckoutSdkContext\";\nvar parseCheckoutSdkContext = function parseCheckoutSdkContext(ctx, useCase) {\n    if (!ctx) {\n        throw new Error(\"Could not find CheckoutProvider context; You need to wrap the part of your app that \".concat(useCase, \" in an <CheckoutProvider> provider.\"));\n    }\n    return ctx;\n};\nvar CheckoutContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nCheckoutContext.displayName = \"CheckoutContext\";\nvar extractCheckoutContextValue = function extractCheckoutContextValue(checkoutSdk, sessionState) {\n    if (!checkoutSdk) {\n        return null;\n    }\n    checkoutSdk.on;\n    checkoutSdk.session;\n    var actions = _objectWithoutProperties(checkoutSdk, _excluded$1);\n    if (!sessionState) {\n        return Object.assign(checkoutSdk.session(), actions);\n    }\n    return Object.assign(sessionState, actions);\n};\nvar INVALID_STRIPE_ERROR$1 = \"Invalid prop `stripe` supplied to `CheckoutProvider`. We recommend using the `loadStripe` utility from `@stripe/stripe-js`. See https://stripe.com/docs/stripe-js/react#elements-props-stripe for details.\";\nvar CheckoutProvider = function CheckoutProvider(_ref) {\n    var rawStripeProp = _ref.stripe, options = _ref.options, children = _ref.children;\n    var parsed = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function() {\n        return parseStripeProp(rawStripeProp, INVALID_STRIPE_ERROR$1);\n    }, [\n        rawStripeProp\n    ]); // State used to trigger a re-render when sdk.session is updated\n    var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), session = _React$useState2[0], setSession = _React$useState2[1];\n    var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_0__.useState(function() {\n        return {\n            stripe: parsed.tag === \"sync\" ? parsed.stripe : null,\n            checkoutSdk: null\n        };\n    }), _React$useState4 = _slicedToArray(_React$useState3, 2), ctx = _React$useState4[0], setContext = _React$useState4[1];\n    var safeSetContext = function safeSetContext(stripe, checkoutSdk) {\n        setContext(function(ctx) {\n            if (ctx.stripe && ctx.checkoutSdk) {\n                return ctx;\n            }\n            return {\n                stripe: stripe,\n                checkoutSdk: checkoutSdk\n            };\n        });\n    }; // Ref used to avoid calling initCheckout multiple times when options changes\n    var initCheckoutCalledRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        var isMounted = true;\n        if (parsed.tag === \"async\" && !ctx.stripe) {\n            parsed.stripePromise.then(function(stripe) {\n                if (stripe && isMounted && !initCheckoutCalledRef.current) {\n                    // Only update context if the component is still mounted\n                    // and stripe is not null. We allow stripe to be null to make\n                    // handling SSR easier.\n                    initCheckoutCalledRef.current = true;\n                    stripe.initCheckout(options).then(function(checkoutSdk) {\n                        if (checkoutSdk) {\n                            safeSetContext(stripe, checkoutSdk);\n                            checkoutSdk.on(\"change\", setSession);\n                        }\n                    });\n                }\n            });\n        } else if (parsed.tag === \"sync\" && parsed.stripe && !initCheckoutCalledRef.current) {\n            initCheckoutCalledRef.current = true;\n            parsed.stripe.initCheckout(options).then(function(checkoutSdk) {\n                if (checkoutSdk) {\n                    safeSetContext(parsed.stripe, checkoutSdk);\n                    checkoutSdk.on(\"change\", setSession);\n                }\n            });\n        }\n        return function() {\n            isMounted = false;\n        };\n    }, [\n        parsed,\n        ctx,\n        options,\n        setSession\n    ]); // Warn on changes to stripe prop\n    var prevStripe = usePrevious(rawStripeProp);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        if (prevStripe !== null && prevStripe !== rawStripeProp) {\n            console.warn(\"Unsupported prop change on CheckoutProvider: You cannot change the `stripe` prop after setting it.\");\n        }\n    }, [\n        prevStripe,\n        rawStripeProp\n    ]); // Apply updates to elements when options prop has relevant changes\n    var prevOptions = usePrevious(options);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        var _prevOptions$elements, _options$elementsOpti;\n        if (!ctx.checkoutSdk) {\n            return;\n        }\n        var previousAppearance = prevOptions === null || prevOptions === void 0 ? void 0 : (_prevOptions$elements = prevOptions.elementsOptions) === null || _prevOptions$elements === void 0 ? void 0 : _prevOptions$elements.appearance;\n        var currentAppearance = options === null || options === void 0 ? void 0 : (_options$elementsOpti = options.elementsOptions) === null || _options$elementsOpti === void 0 ? void 0 : _options$elementsOpti.appearance;\n        if (currentAppearance && !isEqual(currentAppearance, previousAppearance)) {\n            ctx.checkoutSdk.changeAppearance(currentAppearance);\n        }\n    }, [\n        options,\n        prevOptions,\n        ctx.checkoutSdk\n    ]); // Attach react-stripe-js version to stripe.js instance\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        registerWithStripeJs(ctx.stripe);\n    }, [\n        ctx.stripe\n    ]);\n    var checkoutContextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function() {\n        return extractCheckoutContextValue(ctx.checkoutSdk, session);\n    }, [\n        ctx.checkoutSdk,\n        session\n    ]);\n    if (!ctx.checkoutSdk) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CheckoutSdkContext.Provider, {\n        value: ctx\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CheckoutContext.Provider, {\n        value: checkoutContextValue\n    }, children));\n};\nCheckoutProvider.propTypes = {\n    stripe: prop_types__WEBPACK_IMPORTED_MODULE_1__.any,\n    options: prop_types__WEBPACK_IMPORTED_MODULE_1__.shape({\n        fetchClientSecret: prop_types__WEBPACK_IMPORTED_MODULE_1__.func.isRequired,\n        elementsOptions: prop_types__WEBPACK_IMPORTED_MODULE_1__.object\n    }).isRequired\n};\nvar useCheckoutSdkContextWithUseCase = function useCheckoutSdkContextWithUseCase(useCaseString) {\n    var ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CheckoutSdkContext);\n    return parseCheckoutSdkContext(ctx, useCaseString);\n};\nvar useElementsOrCheckoutSdkContextWithUseCase = function useElementsOrCheckoutSdkContextWithUseCase(useCaseString) {\n    var checkoutSdkContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CheckoutSdkContext);\n    var elementsContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ElementsContext);\n    if (checkoutSdkContext && elementsContext) {\n        throw new Error(\"You cannot wrap the part of your app that \".concat(useCaseString, \" in both <CheckoutProvider> and <Elements> providers.\"));\n    }\n    if (checkoutSdkContext) {\n        return parseCheckoutSdkContext(checkoutSdkContext, useCaseString);\n    }\n    return parseElementsContext(elementsContext, useCaseString);\n};\nvar useCheckout = function useCheckout() {\n    // ensure it's in CheckoutProvider\n    useCheckoutSdkContextWithUseCase(\"calls useCheckout()\");\n    var ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CheckoutContext);\n    if (!ctx) {\n        throw new Error(\"Could not find Checkout Context; You need to wrap the part of your app that calls useCheckout() in an <CheckoutProvider> provider.\");\n    }\n    return ctx;\n};\nvar _excluded = [\n    \"mode\"\n];\nvar capitalized = function capitalized(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n};\nvar createElementComponent = function createElementComponent(type, isServer) {\n    var displayName = \"\".concat(capitalized(type), \"Element\");\n    var ClientElement = function ClientElement(_ref) {\n        var id = _ref.id, className = _ref.className, _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options, onBlur = _ref.onBlur, onFocus = _ref.onFocus, onReady = _ref.onReady, onChange = _ref.onChange, onEscape = _ref.onEscape, onClick = _ref.onClick, onLoadError = _ref.onLoadError, onLoaderStart = _ref.onLoaderStart, onNetworksChange = _ref.onNetworksChange, onConfirm = _ref.onConfirm, onCancel = _ref.onCancel, onShippingAddressChange = _ref.onShippingAddressChange, onShippingRateChange = _ref.onShippingRateChange;\n        var ctx = useElementsOrCheckoutSdkContextWithUseCase(\"mounts <\".concat(displayName, \">\"));\n        var elements = \"elements\" in ctx ? ctx.elements : null;\n        var checkoutSdk = \"checkoutSdk\" in ctx ? ctx.checkoutSdk : null;\n        var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), element = _React$useState2[0], setElement = _React$useState2[1];\n        var elementRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n        var domNode = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null); // For every event where the merchant provides a callback, call element.on\n        // with that callback. If the merchant ever changes the callback, removes\n        // the old callback with element.off and then call element.on with the new one.\n        useAttachEvent(element, \"blur\", onBlur);\n        useAttachEvent(element, \"focus\", onFocus);\n        useAttachEvent(element, \"escape\", onEscape);\n        useAttachEvent(element, \"click\", onClick);\n        useAttachEvent(element, \"loaderror\", onLoadError);\n        useAttachEvent(element, \"loaderstart\", onLoaderStart);\n        useAttachEvent(element, \"networkschange\", onNetworksChange);\n        useAttachEvent(element, \"confirm\", onConfirm);\n        useAttachEvent(element, \"cancel\", onCancel);\n        useAttachEvent(element, \"shippingaddresschange\", onShippingAddressChange);\n        useAttachEvent(element, \"shippingratechange\", onShippingRateChange);\n        useAttachEvent(element, \"change\", onChange);\n        var readyCallback;\n        if (onReady) {\n            if (type === \"expressCheckout\") {\n                // Passes through the event, which includes visible PM types\n                readyCallback = onReady;\n            } else {\n                // For other Elements, pass through the Element itself.\n                readyCallback = function readyCallback() {\n                    onReady(element);\n                };\n            }\n        }\n        useAttachEvent(element, \"ready\", readyCallback);\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function() {\n            if (elementRef.current === null && domNode.current !== null && (elements || checkoutSdk)) {\n                var newElement = null;\n                if (checkoutSdk) {\n                    switch(type){\n                        case \"payment\":\n                            newElement = checkoutSdk.createPaymentElement(options);\n                            break;\n                        case \"address\":\n                            if (\"mode\" in options) {\n                                var mode = options.mode, restOptions = _objectWithoutProperties(options, _excluded);\n                                if (mode === \"shipping\") {\n                                    newElement = checkoutSdk.createShippingAddressElement(restOptions);\n                                } else if (mode === \"billing\") {\n                                    newElement = checkoutSdk.createBillingAddressElement(restOptions);\n                                } else {\n                                    throw new Error(\"Invalid options.mode. mode must be 'billing' or 'shipping'.\");\n                                }\n                            } else {\n                                throw new Error(\"You must supply options.mode. mode must be 'billing' or 'shipping'.\");\n                            }\n                            break;\n                        case \"expressCheckout\":\n                            newElement = checkoutSdk.createExpressCheckoutElement(options);\n                            break;\n                        case \"currencySelector\":\n                            newElement = checkoutSdk.createCurrencySelectorElement();\n                            break;\n                        default:\n                            throw new Error(\"Invalid Element type \".concat(displayName, \". You must use either the <PaymentElement />, <AddressElement options={{mode: 'shipping'}} />, <AddressElement options={{mode: 'billing'}} />, or <ExpressCheckoutElement />.\"));\n                    }\n                } else if (elements) {\n                    newElement = elements.create(type, options);\n                } // Store element in a ref to ensure it's _immediately_ available in cleanup hooks in StrictMode\n                elementRef.current = newElement; // Store element in state to facilitate event listener attachment\n                setElement(newElement);\n                if (newElement) {\n                    newElement.mount(domNode.current);\n                }\n            }\n        }, [\n            elements,\n            checkoutSdk,\n            options\n        ]);\n        var prevOptions = usePrevious(options);\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n            if (!elementRef.current) {\n                return;\n            }\n            var updates = extractAllowedOptionsUpdates(options, prevOptions, [\n                \"paymentRequest\"\n            ]);\n            if (updates && \"update\" in elementRef.current) {\n                elementRef.current.update(updates);\n            }\n        }, [\n            options,\n            prevOptions\n        ]);\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function() {\n            return function() {\n                if (elementRef.current && typeof elementRef.current.destroy === \"function\") {\n                    try {\n                        elementRef.current.destroy();\n                        elementRef.current = null;\n                    } catch (error) {}\n                }\n            };\n        }, []);\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            id: id,\n            className: className,\n            ref: domNode\n        });\n    }; // Only render the Element wrapper in a server environment.\n    var ServerElement = function ServerElement(props) {\n        useElementsOrCheckoutSdkContextWithUseCase(\"mounts <\".concat(displayName, \">\"));\n        var id = props.id, className = props.className;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            id: id,\n            className: className\n        });\n    };\n    var Element = isServer ? ServerElement : ClientElement;\n    Element.propTypes = {\n        id: prop_types__WEBPACK_IMPORTED_MODULE_1__.string,\n        className: prop_types__WEBPACK_IMPORTED_MODULE_1__.string,\n        onChange: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onBlur: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onFocus: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onReady: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onEscape: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onClick: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onLoadError: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onLoaderStart: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onNetworksChange: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onConfirm: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onCancel: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onShippingAddressChange: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        onShippingRateChange: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n        options: prop_types__WEBPACK_IMPORTED_MODULE_1__.object\n    };\n    Element.displayName = displayName;\n    Element.__elementType = type;\n    return Element;\n};\nvar isServer = \"undefined\" === \"undefined\";\nvar EmbeddedCheckoutContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nEmbeddedCheckoutContext.displayName = \"EmbeddedCheckoutProviderContext\";\nvar useEmbeddedCheckoutContext = function useEmbeddedCheckoutContext() {\n    var ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(EmbeddedCheckoutContext);\n    if (!ctx) {\n        throw new Error(\"<EmbeddedCheckout> must be used within <EmbeddedCheckoutProvider>\");\n    }\n    return ctx;\n};\nvar INVALID_STRIPE_ERROR = \"Invalid prop `stripe` supplied to `EmbeddedCheckoutProvider`. We recommend using the `loadStripe` utility from `@stripe/stripe-js`. See https://stripe.com/docs/stripe-js/react#elements-props-stripe for details.\";\nvar EmbeddedCheckoutProvider = function EmbeddedCheckoutProvider(_ref) {\n    var rawStripeProp = _ref.stripe, options = _ref.options, children = _ref.children;\n    var parsed = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function() {\n        return parseStripeProp(rawStripeProp, INVALID_STRIPE_ERROR);\n    }, [\n        rawStripeProp\n    ]);\n    var embeddedCheckoutPromise = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    var loadedStripe = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        embeddedCheckout: null\n    }), _React$useState2 = _slicedToArray(_React$useState, 2), ctx = _React$useState2[0], setContext = _React$useState2[1];\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        // Don't support any ctx updates once embeddedCheckout or stripe is set.\n        if (loadedStripe.current || embeddedCheckoutPromise.current) {\n            return;\n        }\n        var setStripeAndInitEmbeddedCheckout = function setStripeAndInitEmbeddedCheckout(stripe) {\n            if (loadedStripe.current || embeddedCheckoutPromise.current) return;\n            loadedStripe.current = stripe;\n            embeddedCheckoutPromise.current = loadedStripe.current.initEmbeddedCheckout(options).then(function(embeddedCheckout) {\n                setContext({\n                    embeddedCheckout: embeddedCheckout\n                });\n            });\n        }; // For an async stripePromise, store it once resolved\n        if (parsed.tag === \"async\" && !loadedStripe.current && (options.clientSecret || options.fetchClientSecret)) {\n            parsed.stripePromise.then(function(stripe) {\n                if (stripe) {\n                    setStripeAndInitEmbeddedCheckout(stripe);\n                }\n            });\n        } else if (parsed.tag === \"sync\" && !loadedStripe.current && (options.clientSecret || options.fetchClientSecret)) {\n            // Or, handle a sync stripe instance going from null -> populated\n            setStripeAndInitEmbeddedCheckout(parsed.stripe);\n        }\n    }, [\n        parsed,\n        options,\n        ctx,\n        loadedStripe\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        // cleanup on unmount\n        return function() {\n            // If embedded checkout is fully initialized, destroy it.\n            if (ctx.embeddedCheckout) {\n                embeddedCheckoutPromise.current = null;\n                ctx.embeddedCheckout.destroy();\n            } else if (embeddedCheckoutPromise.current) {\n                // If embedded checkout is still initializing, destroy it once\n                // it's done. This could be caused by unmounting very quickly\n                // after mounting.\n                embeddedCheckoutPromise.current.then(function() {\n                    embeddedCheckoutPromise.current = null;\n                    if (ctx.embeddedCheckout) {\n                        ctx.embeddedCheckout.destroy();\n                    }\n                });\n            }\n        };\n    }, [\n        ctx.embeddedCheckout\n    ]); // Attach react-stripe-js version to stripe.js instance\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        registerWithStripeJs(loadedStripe);\n    }, [\n        loadedStripe\n    ]); // Warn on changes to stripe prop.\n    // The stripe prop value can only go from null to non-null once and\n    // can't be changed after that.\n    var prevStripe = usePrevious(rawStripeProp);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        if (prevStripe !== null && prevStripe !== rawStripeProp) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the `stripe` prop after setting it.\");\n        }\n    }, [\n        prevStripe,\n        rawStripeProp\n    ]); // Warn on changes to options.\n    var prevOptions = usePrevious(options);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        if (prevOptions == null) {\n            return;\n        }\n        if (options == null) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot unset options after setting them.\");\n            return;\n        }\n        if (options.clientSecret === undefined && options.fetchClientSecret === undefined) {\n            console.warn(\"Invalid props passed to EmbeddedCheckoutProvider: You must provide one of either `options.fetchClientSecret` or `options.clientSecret`.\");\n        }\n        if (prevOptions.clientSecret != null && options.clientSecret !== prevOptions.clientSecret) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the client secret after setting it. Unmount and create a new instance of EmbeddedCheckoutProvider instead.\");\n        }\n        if (prevOptions.fetchClientSecret != null && options.fetchClientSecret !== prevOptions.fetchClientSecret) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot change fetchClientSecret after setting it. Unmount and create a new instance of EmbeddedCheckoutProvider instead.\");\n        }\n        if (prevOptions.onComplete != null && options.onComplete !== prevOptions.onComplete) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the onComplete option after setting it.\");\n        }\n        if (prevOptions.onShippingDetailsChange != null && options.onShippingDetailsChange !== prevOptions.onShippingDetailsChange) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the onShippingDetailsChange option after setting it.\");\n        }\n        if (prevOptions.onLineItemsChange != null && options.onLineItemsChange !== prevOptions.onLineItemsChange) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the onLineItemsChange option after setting it.\");\n        }\n    }, [\n        prevOptions,\n        options\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EmbeddedCheckoutContext.Provider, {\n        value: ctx\n    }, children);\n};\nvar EmbeddedCheckoutClientElement = function EmbeddedCheckoutClientElement(_ref) {\n    var id = _ref.id, className = _ref.className;\n    var _useEmbeddedCheckoutC = useEmbeddedCheckoutContext(), embeddedCheckout = _useEmbeddedCheckoutC.embeddedCheckout;\n    var isMounted = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    var domNode = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function() {\n        if (!isMounted.current && embeddedCheckout && domNode.current !== null) {\n            embeddedCheckout.mount(domNode.current);\n            isMounted.current = true;\n        } // Clean up on unmount\n        return function() {\n            if (isMounted.current && embeddedCheckout) {\n                try {\n                    embeddedCheckout.unmount();\n                    isMounted.current = false;\n                } catch (e) {\n                // Parent effects are destroyed before child effects, so\n                // in cases where both the EmbeddedCheckoutProvider and\n                // the EmbeddedCheckout component are removed at the same\n                // time, the embeddedCheckout instance will be destroyed,\n                // which causes an error when calling unmount.\n                }\n            }\n        };\n    }, [\n        embeddedCheckout\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: domNode,\n        id: id,\n        className: className\n    });\n}; // Only render the wrapper in a server environment.\nvar EmbeddedCheckoutServerElement = function EmbeddedCheckoutServerElement(_ref2) {\n    var id = _ref2.id, className = _ref2.className;\n    // Validate that we are in the right context by calling useEmbeddedCheckoutContext.\n    useEmbeddedCheckoutContext();\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        id: id,\n        className: className\n    });\n};\nvar EmbeddedCheckout = isServer ? EmbeddedCheckoutServerElement : EmbeddedCheckoutClientElement;\n/**\n * @docs https://stripe.com/docs/stripe-js/react#usestripe-hook\n */ var useStripe = function useStripe() {\n    var _useElementsOrCheckou = useElementsOrCheckoutSdkContextWithUseCase(\"calls useStripe()\"), stripe = _useElementsOrCheckou.stripe;\n    return stripe;\n};\n/**\n * Requires beta access:\n * Contact [Stripe support](https://support.stripe.com/) for more information.\n *\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var AuBankAccountElement = createElementComponent(\"auBankAccount\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var CardElement = createElementComponent(\"card\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var CardNumberElement = createElementComponent(\"cardNumber\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var CardExpiryElement = createElementComponent(\"cardExpiry\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var CardCvcElement = createElementComponent(\"cardCvc\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var FpxBankElement = createElementComponent(\"fpxBank\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var IbanElement = createElementComponent(\"iban\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var IdealBankElement = createElementComponent(\"idealBank\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var P24BankElement = createElementComponent(\"p24Bank\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var EpsBankElement = createElementComponent(\"epsBank\", isServer);\nvar PaymentElement = createElementComponent(\"payment\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var ExpressCheckoutElement = createElementComponent(\"expressCheckout\", isServer);\n/**\n * Requires beta access:\n * Contact [Stripe support](https://support.stripe.com/) for more information.\n */ var CurrencySelectorElement = createElementComponent(\"currencySelector\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var PaymentRequestButtonElement = createElementComponent(\"paymentRequestButton\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var LinkAuthenticationElement = createElementComponent(\"linkAuthentication\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var AddressElement = createElementComponent(\"address\", isServer);\n/**\n * @deprecated\n * Use `AddressElement` instead.\n *\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var ShippingAddressElement = createElementComponent(\"shippingAddress\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var PaymentMethodMessagingElement = createElementComponent(\"paymentMethodMessaging\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var AffirmMessageElement = createElementComponent(\"affirmMessage\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var AfterpayClearpayMessageElement = createElementComponent(\"afterpayClearpayMessage\", isServer);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9yZWFjdC1zdHJpcGUtanMvZGlzdC9yZWFjdC1zdHJpcGUuZXNtLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEI7QUFDUztBQUVuQyxTQUFTRSxRQUFRQyxNQUFNLEVBQUVDLGNBQWM7SUFDckMsSUFBSUMsT0FBT0MsT0FBT0QsSUFBSSxDQUFDRjtJQUV2QixJQUFJRyxPQUFPQyxxQkFBcUIsRUFBRTtRQUNoQyxJQUFJQyxVQUFVRixPQUFPQyxxQkFBcUIsQ0FBQ0o7UUFFM0MsSUFBSUMsZ0JBQWdCO1lBQ2xCSSxVQUFVQSxRQUFRQyxNQUFNLENBQUMsU0FBVUMsR0FBRztnQkFDcEMsT0FBT0osT0FBT0ssd0JBQXdCLENBQUNSLFFBQVFPLEtBQUtFLFVBQVU7WUFDaEU7UUFDRjtRQUVBUCxLQUFLUSxJQUFJLENBQUNDLEtBQUssQ0FBQ1QsTUFBTUc7SUFDeEI7SUFFQSxPQUFPSDtBQUNUO0FBRUEsU0FBU1UsZUFBZUMsTUFBTTtJQUM1QixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1FBQ3pDLElBQUlHLFNBQVNGLFNBQVMsQ0FBQ0QsRUFBRSxJQUFJLE9BQU9DLFNBQVMsQ0FBQ0QsRUFBRSxHQUFHLENBQUM7UUFFcEQsSUFBSUEsSUFBSSxHQUFHO1lBQ1RmLFFBQVFJLE9BQU9jLFNBQVMsTUFBTUMsT0FBTyxDQUFDLFNBQVVDLEdBQUc7Z0JBQ2pEQyxnQkFBZ0JQLFFBQVFNLEtBQUtGLE1BQU0sQ0FBQ0UsSUFBSTtZQUMxQztRQUNGLE9BQU8sSUFBSWhCLE9BQU9rQix5QkFBeUIsRUFBRTtZQUMzQ2xCLE9BQU9tQixnQkFBZ0IsQ0FBQ1QsUUFBUVYsT0FBT2tCLHlCQUF5QixDQUFDSjtRQUNuRSxPQUFPO1lBQ0xsQixRQUFRSSxPQUFPYyxTQUFTQyxPQUFPLENBQUMsU0FBVUMsR0FBRztnQkFDM0NoQixPQUFPb0Is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L25vZmFwLWFwcC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL0BzdHJpcGUvcmVhY3Qtc3RyaXBlLWpzL2Rpc3QvcmVhY3Qtc3RyaXBlLmVzbS5tanM/YTE1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuXG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSB7XG4gICAgICBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcblxuICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG5cbiAgdmFyIGtleSwgaTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICB2YXIgX2kgPSBhcnIgJiYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXSk7XG5cbiAgaWYgKF9pID09IG51bGwpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG5cbiAgdmFyIF9zLCBfZTtcblxuICB0cnkge1xuICAgIGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxudmFyIHVzZUF0dGFjaEV2ZW50ID0gZnVuY3Rpb24gdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgZXZlbnQsIGNiKSB7XG4gIHZhciBjYkRlZmluZWQgPSAhIWNiO1xuICB2YXIgY2JSZWYgPSBSZWFjdC51c2VSZWYoY2IpOyAvLyBJbiBtYW55IGludGVncmF0aW9ucyB0aGUgY2FsbGJhY2sgcHJvcCBjaGFuZ2VzIG9uIGVhY2ggcmVuZGVyLlxuICAvLyBVc2luZyBhIHJlZiBzYXZlcyB1cyBmcm9tIGNhbGxpbmcgZWxlbWVudC5vbi8ub2ZmIGV2ZXJ5IHJlbmRlci5cblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGNiUmVmLmN1cnJlbnQgPSBjYjtcbiAgfSwgW2NiXSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYkRlZmluZWQgfHwgIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7fTtcbiAgICB9XG5cbiAgICB2YXIgZGVjb3JhdGVkQ2IgPSBmdW5jdGlvbiBkZWNvcmF0ZWRDYigpIHtcbiAgICAgIGlmIChjYlJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNiUmVmLmN1cnJlbnQuYXBwbHkoY2JSZWYsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGVsZW1lbnQub24oZXZlbnQsIGRlY29yYXRlZENiKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZWxlbWVudC5vZmYoZXZlbnQsIGRlY29yYXRlZENiKTtcbiAgICB9O1xuICB9LCBbY2JEZWZpbmVkLCBldmVudCwgZWxlbWVudCwgY2JSZWZdKTtcbn07XG5cbnZhciB1c2VQcmV2aW91cyA9IGZ1bmN0aW9uIHVzZVByZXZpb3VzKHZhbHVlKSB7XG4gIHZhciByZWYgPSBSZWFjdC51c2VSZWYodmFsdWUpO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH0sIFt2YWx1ZV0pO1xuICByZXR1cm4gcmVmLmN1cnJlbnQ7XG59O1xuXG52YXIgaXNVbmtub3duT2JqZWN0ID0gZnVuY3Rpb24gaXNVbmtub3duT2JqZWN0KHJhdykge1xuICByZXR1cm4gcmF3ICE9PSBudWxsICYmIF90eXBlb2YocmF3KSA9PT0gJ29iamVjdCc7XG59O1xudmFyIGlzUHJvbWlzZSA9IGZ1bmN0aW9uIGlzUHJvbWlzZShyYXcpIHtcbiAgcmV0dXJuIGlzVW5rbm93bk9iamVjdChyYXcpICYmIHR5cGVvZiByYXcudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn07IC8vIFdlIGFyZSB1c2luZyB0eXBlcyB0byBlbmZvcmNlIHRoZSBgc3RyaXBlYCBwcm9wIGluIHRoaXMgbGliLFxuLy8gYnV0IGluIGFuIHVudHlwZWQgaW50ZWdyYXRpb24gYHN0cmlwZWAgY291bGQgYmUgYW55dGhpbmcsIHNvIHdlIG5lZWRcbi8vIHRvIGRvIHNvbWUgc2FuaXR5IHZhbGlkYXRpb24gdG8gcHJldmVudCB0eXBlIGVycm9ycy5cblxudmFyIGlzU3RyaXBlID0gZnVuY3Rpb24gaXNTdHJpcGUocmF3KSB7XG4gIHJldHVybiBpc1Vua25vd25PYmplY3QocmF3KSAmJiB0eXBlb2YgcmF3LmVsZW1lbnRzID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiByYXcuY3JlYXRlVG9rZW4gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHJhdy5jcmVhdGVQYXltZW50TWV0aG9kID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiByYXcuY29uZmlybUNhcmRQYXltZW50ID09PSAnZnVuY3Rpb24nO1xufTtcblxudmFyIFBMQUlOX09CSkVDVF9TVFIgPSAnW29iamVjdCBPYmplY3RdJztcbnZhciBpc0VxdWFsID0gZnVuY3Rpb24gaXNFcXVhbChsZWZ0LCByaWdodCkge1xuICBpZiAoIWlzVW5rbm93bk9iamVjdChsZWZ0KSB8fCAhaXNVbmtub3duT2JqZWN0KHJpZ2h0KSkge1xuICAgIHJldHVybiBsZWZ0ID09PSByaWdodDtcbiAgfVxuXG4gIHZhciBsZWZ0QXJyYXkgPSBBcnJheS5pc0FycmF5KGxlZnQpO1xuICB2YXIgcmlnaHRBcnJheSA9IEFycmF5LmlzQXJyYXkocmlnaHQpO1xuICBpZiAobGVmdEFycmF5ICE9PSByaWdodEFycmF5KSByZXR1cm4gZmFsc2U7XG4gIHZhciBsZWZ0UGxhaW5PYmplY3QgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobGVmdCkgPT09IFBMQUlOX09CSkVDVF9TVFI7XG4gIHZhciByaWdodFBsYWluT2JqZWN0ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJpZ2h0KSA9PT0gUExBSU5fT0JKRUNUX1NUUjtcbiAgaWYgKGxlZnRQbGFpbk9iamVjdCAhPT0gcmlnaHRQbGFpbk9iamVjdCkgcmV0dXJuIGZhbHNlOyAvLyBub3Qgc3VyZSB3aGF0IHNvcnQgb2Ygc3BlY2lhbCBvYmplY3QgdGhpcyBpcyAocmVnZXhwIGlzIG9uZSBvcHRpb24pLCBzb1xuICAvLyBmYWxsYmFjayB0byByZWZlcmVuY2UgY2hlY2suXG5cbiAgaWYgKCFsZWZ0UGxhaW5PYmplY3QgJiYgIWxlZnRBcnJheSkgcmV0dXJuIGxlZnQgPT09IHJpZ2h0O1xuICB2YXIgbGVmdEtleXMgPSBPYmplY3Qua2V5cyhsZWZ0KTtcbiAgdmFyIHJpZ2h0S2V5cyA9IE9iamVjdC5rZXlzKHJpZ2h0KTtcbiAgaWYgKGxlZnRLZXlzLmxlbmd0aCAhPT0gcmlnaHRLZXlzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICB2YXIga2V5U2V0ID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWZ0S2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGtleVNldFtsZWZ0S2V5c1tpXV0gPSB0cnVlO1xuICB9XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHJpZ2h0S2V5cy5sZW5ndGg7IF9pICs9IDEpIHtcbiAgICBrZXlTZXRbcmlnaHRLZXlzW19pXV0gPSB0cnVlO1xuICB9XG5cbiAgdmFyIGFsbEtleXMgPSBPYmplY3Qua2V5cyhrZXlTZXQpO1xuXG4gIGlmIChhbGxLZXlzLmxlbmd0aCAhPT0gbGVmdEtleXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGwgPSBsZWZ0O1xuICB2YXIgciA9IHJpZ2h0O1xuXG4gIHZhciBwcmVkID0gZnVuY3Rpb24gcHJlZChrZXkpIHtcbiAgICByZXR1cm4gaXNFcXVhbChsW2tleV0sIHJba2V5XSk7XG4gIH07XG5cbiAgcmV0dXJuIGFsbEtleXMuZXZlcnkocHJlZCk7XG59O1xuXG52YXIgZXh0cmFjdEFsbG93ZWRPcHRpb25zVXBkYXRlcyA9IGZ1bmN0aW9uIGV4dHJhY3RBbGxvd2VkT3B0aW9uc1VwZGF0ZXMob3B0aW9ucywgcHJldk9wdGlvbnMsIGltbXV0YWJsZUtleXMpIHtcbiAgaWYgKCFpc1Vua25vd25PYmplY3Qob3B0aW9ucykpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBPYmplY3Qua2V5cyhvcHRpb25zKS5yZWR1Y2UoZnVuY3Rpb24gKG5ld09wdGlvbnMsIGtleSkge1xuICAgIHZhciBpc1VwZGF0ZWQgPSAhaXNVbmtub3duT2JqZWN0KHByZXZPcHRpb25zKSB8fCAhaXNFcXVhbChvcHRpb25zW2tleV0sIHByZXZPcHRpb25zW2tleV0pO1xuXG4gICAgaWYgKGltbXV0YWJsZUtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgaWYgKGlzVXBkYXRlZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJVbnN1cHBvcnRlZCBwcm9wIGNoYW5nZTogb3B0aW9ucy5cIi5jb25jYXQoa2V5LCBcIiBpcyBub3QgYSBtdXRhYmxlIHByb3BlcnR5LlwiKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdPcHRpb25zO1xuICAgIH1cblxuICAgIGlmICghaXNVcGRhdGVkKSB7XG4gICAgICByZXR1cm4gbmV3T3B0aW9ucztcbiAgICB9XG5cbiAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG5ld09wdGlvbnMgfHwge30pLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBrZXksIG9wdGlvbnNba2V5XSkpO1xuICB9LCBudWxsKTtcbn07XG5cbnZhciBJTlZBTElEX1NUUklQRV9FUlJPUiQyID0gJ0ludmFsaWQgcHJvcCBgc3RyaXBlYCBzdXBwbGllZCB0byBgRWxlbWVudHNgLiBXZSByZWNvbW1lbmQgdXNpbmcgdGhlIGBsb2FkU3RyaXBlYCB1dGlsaXR5IGZyb20gYEBzdHJpcGUvc3RyaXBlLWpzYC4gU2VlIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50cy1wcm9wcy1zdHJpcGUgZm9yIGRldGFpbHMuJzsgLy8gV2UgYXJlIHVzaW5nIHR5cGVzIHRvIGVuZm9yY2UgdGhlIGBzdHJpcGVgIHByb3AgaW4gdGhpcyBsaWIsIGJ1dCBpbiBhIHJlYWxcbi8vIGludGVncmF0aW9uIGBzdHJpcGVgIGNvdWxkIGJlIGFueXRoaW5nLCBzbyB3ZSBuZWVkIHRvIGRvIHNvbWUgc2FuaXR5XG4vLyB2YWxpZGF0aW9uIHRvIHByZXZlbnQgdHlwZSBlcnJvcnMuXG5cbnZhciB2YWxpZGF0ZVN0cmlwZSA9IGZ1bmN0aW9uIHZhbGlkYXRlU3RyaXBlKG1heWJlU3RyaXBlKSB7XG4gIHZhciBlcnJvck1zZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogSU5WQUxJRF9TVFJJUEVfRVJST1IkMjtcblxuICBpZiAobWF5YmVTdHJpcGUgPT09IG51bGwgfHwgaXNTdHJpcGUobWF5YmVTdHJpcGUpKSB7XG4gICAgcmV0dXJuIG1heWJlU3RyaXBlO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKTtcbn07XG5cbnZhciBwYXJzZVN0cmlwZVByb3AgPSBmdW5jdGlvbiBwYXJzZVN0cmlwZVByb3AocmF3KSB7XG4gIHZhciBlcnJvck1zZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogSU5WQUxJRF9TVFJJUEVfRVJST1IkMjtcblxuICBpZiAoaXNQcm9taXNlKHJhdykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGFnOiAnYXN5bmMnLFxuICAgICAgc3RyaXBlUHJvbWlzZTogUHJvbWlzZS5yZXNvbHZlKHJhdykudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZVN0cmlwZShyZXN1bHQsIGVycm9yTXNnKTtcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuXG4gIHZhciBzdHJpcGUgPSB2YWxpZGF0ZVN0cmlwZShyYXcsIGVycm9yTXNnKTtcblxuICBpZiAoc3RyaXBlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhZzogJ2VtcHR5J1xuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRhZzogJ3N5bmMnLFxuICAgIHN0cmlwZTogc3RyaXBlXG4gIH07XG59O1xuXG52YXIgcmVnaXN0ZXJXaXRoU3RyaXBlSnMgPSBmdW5jdGlvbiByZWdpc3RlcldpdGhTdHJpcGVKcyhzdHJpcGUpIHtcbiAgaWYgKCFzdHJpcGUgfHwgIXN0cmlwZS5fcmVnaXN0ZXJXcmFwcGVyIHx8ICFzdHJpcGUucmVnaXN0ZXJBcHBJbmZvKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RyaXBlLl9yZWdpc3RlcldyYXBwZXIoe1xuICAgIG5hbWU6ICdyZWFjdC1zdHJpcGUtanMnLFxuICAgIHZlcnNpb246IFwiMy42LjBcIlxuICB9KTtcblxuICBzdHJpcGUucmVnaXN0ZXJBcHBJbmZvKHtcbiAgICBuYW1lOiAncmVhY3Qtc3RyaXBlLWpzJyxcbiAgICB2ZXJzaW9uOiBcIjMuNi4wXCIsXG4gICAgdXJsOiAnaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0J1xuICB9KTtcbn07XG5cbnZhciBFbGVtZW50c0NvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbkVsZW1lbnRzQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdFbGVtZW50c0NvbnRleHQnO1xudmFyIHBhcnNlRWxlbWVudHNDb250ZXh0ID0gZnVuY3Rpb24gcGFyc2VFbGVtZW50c0NvbnRleHQoY3R4LCB1c2VDYXNlKSB7XG4gIGlmICghY3R4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgRWxlbWVudHMgY29udGV4dDsgWW91IG5lZWQgdG8gd3JhcCB0aGUgcGFydCBvZiB5b3VyIGFwcCB0aGF0IFwiLmNvbmNhdCh1c2VDYXNlLCBcIiBpbiBhbiA8RWxlbWVudHM+IHByb3ZpZGVyLlwiKSk7XG4gIH1cblxuICByZXR1cm4gY3R4O1xufTtcbi8qKlxuICogVGhlIGBFbGVtZW50c2AgcHJvdmlkZXIgYWxsb3dzIHlvdSB0byB1c2UgW0VsZW1lbnQgY29tcG9uZW50c10oaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50cykgYW5kIGFjY2VzcyB0aGUgW1N0cmlwZSBvYmplY3RdKGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL2pzL2luaXRpYWxpemluZykgaW4gYW55IG5lc3RlZCBjb21wb25lbnQuXG4gKiBSZW5kZXIgYW4gYEVsZW1lbnRzYCBwcm92aWRlciBhdCB0aGUgcm9vdCBvZiB5b3VyIFJlYWN0IGFwcCBzbyB0aGF0IGl0IGlzIGF2YWlsYWJsZSBldmVyeXdoZXJlIHlvdSBuZWVkIGl0LlxuICpcbiAqIFRvIHVzZSB0aGUgYEVsZW1lbnRzYCBwcm92aWRlciwgY2FsbCBgbG9hZFN0cmlwZWAgZnJvbSBgQHN0cmlwZS9zdHJpcGUtanNgIHdpdGggeW91ciBwdWJsaXNoYWJsZSBrZXkuXG4gKiBUaGUgYGxvYWRTdHJpcGVgIGZ1bmN0aW9uIHdpbGwgYXN5bmNocm9ub3VzbHkgbG9hZCB0aGUgU3RyaXBlLmpzIHNjcmlwdCBhbmQgaW5pdGlhbGl6ZSBhIGBTdHJpcGVgIG9iamVjdC5cbiAqIFBhc3MgdGhlIHJldHVybmVkIGBQcm9taXNlYCB0byBgRWxlbWVudHNgLlxuICpcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50cy1wcm92aWRlclxuICovXG5cbnZhciBFbGVtZW50cyA9IGZ1bmN0aW9uIEVsZW1lbnRzKF9yZWYpIHtcbiAgdmFyIHJhd1N0cmlwZVByb3AgPSBfcmVmLnN0cmlwZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gIHZhciBwYXJzZWQgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGFyc2VTdHJpcGVQcm9wKHJhd1N0cmlwZVByb3ApO1xuICB9LCBbcmF3U3RyaXBlUHJvcF0pOyAvLyBGb3IgYSBzeW5jIHN0cmlwZSBpbnN0YW5jZSwgaW5pdGlhbGl6ZSBpbnRvIGNvbnRleHRcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdHJpcGU6IHBhcnNlZC50YWcgPT09ICdzeW5jJyA/IHBhcnNlZC5zdHJpcGUgOiBudWxsLFxuICAgICAgZWxlbWVudHM6IHBhcnNlZC50YWcgPT09ICdzeW5jJyA/IHBhcnNlZC5zdHJpcGUuZWxlbWVudHMob3B0aW9ucykgOiBudWxsXG4gICAgfTtcbiAgfSksXG4gICAgICBfUmVhY3QkdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlLCAyKSxcbiAgICAgIGN0eCA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRDb250ZXh0ID0gX1JlYWN0JHVzZVN0YXRlMlsxXTtcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBpc01vdW50ZWQgPSB0cnVlO1xuXG4gICAgdmFyIHNhZmVTZXRDb250ZXh0ID0gZnVuY3Rpb24gc2FmZVNldENvbnRleHQoc3RyaXBlKSB7XG4gICAgICBzZXRDb250ZXh0KGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgLy8gbm8tb3AgaWYgd2UgYWxyZWFkeSBoYXZlIGEgc3RyaXBlIGluc3RhbmNlIChodHRwczovL2dpdGh1Yi5jb20vc3RyaXBlL3JlYWN0LXN0cmlwZS1qcy9pc3N1ZXMvMjk2KVxuICAgICAgICBpZiAoY3R4LnN0cmlwZSkgcmV0dXJuIGN0eDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdHJpcGU6IHN0cmlwZSxcbiAgICAgICAgICBlbGVtZW50czogc3RyaXBlLmVsZW1lbnRzKG9wdGlvbnMpXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9OyAvLyBGb3IgYW4gYXN5bmMgc3RyaXBlUHJvbWlzZSwgc3RvcmUgaXQgaW4gY29udGV4dCBvbmNlIHJlc29sdmVkXG5cblxuICAgIGlmIChwYXJzZWQudGFnID09PSAnYXN5bmMnICYmICFjdHguc3RyaXBlKSB7XG4gICAgICBwYXJzZWQuc3RyaXBlUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChzdHJpcGUpIHtcbiAgICAgICAgaWYgKHN0cmlwZSAmJiBpc01vdW50ZWQpIHtcbiAgICAgICAgICAvLyBPbmx5IHVwZGF0ZSBFbGVtZW50cyBjb250ZXh0IGlmIHRoZSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZFxuICAgICAgICAgIC8vIGFuZCBzdHJpcGUgaXMgbm90IG51bGwuIFdlIGFsbG93IHN0cmlwZSB0byBiZSBudWxsIHRvIG1ha2VcbiAgICAgICAgICAvLyBoYW5kbGluZyBTU1IgZWFzaWVyLlxuICAgICAgICAgIHNhZmVTZXRDb250ZXh0KHN0cmlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocGFyc2VkLnRhZyA9PT0gJ3N5bmMnICYmICFjdHguc3RyaXBlKSB7XG4gICAgICAvLyBPciwgaGFuZGxlIGEgc3luYyBzdHJpcGUgaW5zdGFuY2UgZ29pbmcgZnJvbSBudWxsIC0+IHBvcHVsYXRlZFxuICAgICAgc2FmZVNldENvbnRleHQocGFyc2VkLnN0cmlwZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlzTW91bnRlZCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFtwYXJzZWQsIGN0eCwgb3B0aW9uc10pOyAvLyBXYXJuIG9uIGNoYW5nZXMgdG8gc3RyaXBlIHByb3BcblxuICB2YXIgcHJldlN0cmlwZSA9IHVzZVByZXZpb3VzKHJhd1N0cmlwZVByb3ApO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChwcmV2U3RyaXBlICE9PSBudWxsICYmIHByZXZTdHJpcGUgIT09IHJhd1N0cmlwZVByb3ApIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5zdXBwb3J0ZWQgcHJvcCBjaGFuZ2Ugb24gRWxlbWVudHM6IFlvdSBjYW5ub3QgY2hhbmdlIHRoZSBgc3RyaXBlYCBwcm9wIGFmdGVyIHNldHRpbmcgaXQuJyk7XG4gICAgfVxuICB9LCBbcHJldlN0cmlwZSwgcmF3U3RyaXBlUHJvcF0pOyAvLyBBcHBseSB1cGRhdGVzIHRvIGVsZW1lbnRzIHdoZW4gb3B0aW9ucyBwcm9wIGhhcyByZWxldmFudCBjaGFuZ2VzXG5cbiAgdmFyIHByZXZPcHRpb25zID0gdXNlUHJldmlvdXMob3B0aW9ucyk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjdHguZWxlbWVudHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlcyA9IGV4dHJhY3RBbGxvd2VkT3B0aW9uc1VwZGF0ZXMob3B0aW9ucywgcHJldk9wdGlvbnMsIFsnY2xpZW50U2VjcmV0JywgJ2ZvbnRzJ10pO1xuXG4gICAgaWYgKHVwZGF0ZXMpIHtcbiAgICAgIGN0eC5lbGVtZW50cy51cGRhdGUodXBkYXRlcyk7XG4gICAgfVxuICB9LCBbb3B0aW9ucywgcHJldk9wdGlvbnMsIGN0eC5lbGVtZW50c10pOyAvLyBBdHRhY2ggcmVhY3Qtc3RyaXBlLWpzIHZlcnNpb24gdG8gc3RyaXBlLmpzIGluc3RhbmNlXG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZWdpc3RlcldpdGhTdHJpcGVKcyhjdHguc3RyaXBlKTtcbiAgfSwgW2N0eC5zdHJpcGVdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVsZW1lbnRzQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjdHhcbiAgfSwgY2hpbGRyZW4pO1xufTtcbkVsZW1lbnRzLnByb3BUeXBlcyA9IHtcbiAgc3RyaXBlOiBQcm9wVHlwZXMuYW55LFxuICBvcHRpb25zOiBQcm9wVHlwZXMub2JqZWN0XG59O1xudmFyIHVzZUVsZW1lbnRzQ29udGV4dFdpdGhVc2VDYXNlID0gZnVuY3Rpb24gdXNlRWxlbWVudHNDb250ZXh0V2l0aFVzZUNhc2UodXNlQ2FzZU1lc3NhZ2UpIHtcbiAgdmFyIGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoRWxlbWVudHNDb250ZXh0KTtcbiAgcmV0dXJuIHBhcnNlRWxlbWVudHNDb250ZXh0KGN0eCwgdXNlQ2FzZU1lc3NhZ2UpO1xufTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I3VzZWVsZW1lbnRzLWhvb2tcbiAqL1xuXG52YXIgdXNlRWxlbWVudHMgPSBmdW5jdGlvbiB1c2VFbGVtZW50cygpIHtcbiAgdmFyIF91c2VFbGVtZW50c0NvbnRleHRXaSA9IHVzZUVsZW1lbnRzQ29udGV4dFdpdGhVc2VDYXNlKCdjYWxscyB1c2VFbGVtZW50cygpJyksXG4gICAgICBlbGVtZW50cyA9IF91c2VFbGVtZW50c0NvbnRleHRXaS5lbGVtZW50cztcblxuICByZXR1cm4gZWxlbWVudHM7XG59O1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudHMtY29uc3VtZXJcbiAqL1xuXG52YXIgRWxlbWVudHNDb25zdW1lciA9IGZ1bmN0aW9uIEVsZW1lbnRzQ29uc3VtZXIoX3JlZjIpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZjIuY2hpbGRyZW47XG4gIHZhciBjdHggPSB1c2VFbGVtZW50c0NvbnRleHRXaXRoVXNlQ2FzZSgnbW91bnRzIDxFbGVtZW50c0NvbnN1bWVyPicpOyAvLyBBc3NlcnQgdG8gc2F0aXNmeSB0aGUgYnVzdGVkIFJlYWN0LkZDIHJldHVybiB0eXBlIChpdCBzaG91bGQgYmUgUmVhY3ROb2RlKVxuXG4gIHJldHVybiBjaGlsZHJlbihjdHgpO1xufTtcbkVsZW1lbnRzQ29uc3VtZXIucHJvcFR5cGVzID0ge1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxufTtcblxudmFyIF9leGNsdWRlZCQxID0gW1wib25cIiwgXCJzZXNzaW9uXCJdO1xudmFyIENoZWNrb3V0U2RrQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuQ2hlY2tvdXRTZGtDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0NoZWNrb3V0U2RrQ29udGV4dCc7XG52YXIgcGFyc2VDaGVja291dFNka0NvbnRleHQgPSBmdW5jdGlvbiBwYXJzZUNoZWNrb3V0U2RrQ29udGV4dChjdHgsIHVzZUNhc2UpIHtcbiAgaWYgKCFjdHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBDaGVja291dFByb3ZpZGVyIGNvbnRleHQ7IFlvdSBuZWVkIHRvIHdyYXAgdGhlIHBhcnQgb2YgeW91ciBhcHAgdGhhdCBcIi5jb25jYXQodXNlQ2FzZSwgXCIgaW4gYW4gPENoZWNrb3V0UHJvdmlkZXI+IHByb3ZpZGVyLlwiKSk7XG4gIH1cblxuICByZXR1cm4gY3R4O1xufTtcbnZhciBDaGVja291dENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbkNoZWNrb3V0Q29udGV4dC5kaXNwbGF5TmFtZSA9ICdDaGVja291dENvbnRleHQnO1xudmFyIGV4dHJhY3RDaGVja291dENvbnRleHRWYWx1ZSA9IGZ1bmN0aW9uIGV4dHJhY3RDaGVja291dENvbnRleHRWYWx1ZShjaGVja291dFNkaywgc2Vzc2lvblN0YXRlKSB7XG4gIGlmICghY2hlY2tvdXRTZGspIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNoZWNrb3V0U2RrLm9uO1xuICAgICAgY2hlY2tvdXRTZGsuc2Vzc2lvbjtcbiAgICAgIHZhciBhY3Rpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGNoZWNrb3V0U2RrLCBfZXhjbHVkZWQkMSk7XG5cbiAgaWYgKCFzZXNzaW9uU3RhdGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihjaGVja291dFNkay5zZXNzaW9uKCksIGFjdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oc2Vzc2lvblN0YXRlLCBhY3Rpb25zKTtcbn07XG52YXIgSU5WQUxJRF9TVFJJUEVfRVJST1IkMSA9ICdJbnZhbGlkIHByb3AgYHN0cmlwZWAgc3VwcGxpZWQgdG8gYENoZWNrb3V0UHJvdmlkZXJgLiBXZSByZWNvbW1lbmQgdXNpbmcgdGhlIGBsb2FkU3RyaXBlYCB1dGlsaXR5IGZyb20gYEBzdHJpcGUvc3RyaXBlLWpzYC4gU2VlIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50cy1wcm9wcy1zdHJpcGUgZm9yIGRldGFpbHMuJztcbnZhciBDaGVja291dFByb3ZpZGVyID0gZnVuY3Rpb24gQ2hlY2tvdXRQcm92aWRlcihfcmVmKSB7XG4gIHZhciByYXdTdHJpcGVQcm9wID0gX3JlZi5zdHJpcGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICB2YXIgcGFyc2VkID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBhcnNlU3RyaXBlUHJvcChyYXdTdHJpcGVQcm9wLCBJTlZBTElEX1NUUklQRV9FUlJPUiQxKTtcbiAgfSwgW3Jhd1N0cmlwZVByb3BdKTsgLy8gU3RhdGUgdXNlZCB0byB0cmlnZ2VyIGEgcmUtcmVuZGVyIHdoZW4gc2RrLnNlc3Npb24gaXMgdXBkYXRlZFxuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShudWxsKSxcbiAgICAgIF9SZWFjdCR1c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfUmVhY3QkdXNlU3RhdGUsIDIpLFxuICAgICAgc2Vzc2lvbiA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRTZXNzaW9uID0gX1JlYWN0JHVzZVN0YXRlMlsxXTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlMyA9IFJlYWN0LnVzZVN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RyaXBlOiBwYXJzZWQudGFnID09PSAnc3luYycgPyBwYXJzZWQuc3RyaXBlIDogbnVsbCxcbiAgICAgIGNoZWNrb3V0U2RrOiBudWxsXG4gICAgfTtcbiAgfSksXG4gICAgICBfUmVhY3QkdXNlU3RhdGU0ID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlMywgMiksXG4gICAgICBjdHggPSBfUmVhY3QkdXNlU3RhdGU0WzBdLFxuICAgICAgc2V0Q29udGV4dCA9IF9SZWFjdCR1c2VTdGF0ZTRbMV07XG5cbiAgdmFyIHNhZmVTZXRDb250ZXh0ID0gZnVuY3Rpb24gc2FmZVNldENvbnRleHQoc3RyaXBlLCBjaGVja291dFNkaykge1xuICAgIHNldENvbnRleHQoZnVuY3Rpb24gKGN0eCkge1xuICAgICAgaWYgKGN0eC5zdHJpcGUgJiYgY3R4LmNoZWNrb3V0U2RrKSB7XG4gICAgICAgIHJldHVybiBjdHg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0cmlwZTogc3RyaXBlLFxuICAgICAgICBjaGVja291dFNkazogY2hlY2tvdXRTZGtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07IC8vIFJlZiB1c2VkIHRvIGF2b2lkIGNhbGxpbmcgaW5pdENoZWNrb3V0IG11bHRpcGxlIHRpbWVzIHdoZW4gb3B0aW9ucyBjaGFuZ2VzXG5cblxuICB2YXIgaW5pdENoZWNrb3V0Q2FsbGVkUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaXNNb3VudGVkID0gdHJ1ZTtcblxuICAgIGlmIChwYXJzZWQudGFnID09PSAnYXN5bmMnICYmICFjdHguc3RyaXBlKSB7XG4gICAgICBwYXJzZWQuc3RyaXBlUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChzdHJpcGUpIHtcbiAgICAgICAgaWYgKHN0cmlwZSAmJiBpc01vdW50ZWQgJiYgIWluaXRDaGVja291dENhbGxlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgLy8gT25seSB1cGRhdGUgY29udGV4dCBpZiB0aGUgY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWRcbiAgICAgICAgICAvLyBhbmQgc3RyaXBlIGlzIG5vdCBudWxsLiBXZSBhbGxvdyBzdHJpcGUgdG8gYmUgbnVsbCB0byBtYWtlXG4gICAgICAgICAgLy8gaGFuZGxpbmcgU1NSIGVhc2llci5cbiAgICAgICAgICBpbml0Q2hlY2tvdXRDYWxsZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgc3RyaXBlLmluaXRDaGVja291dChvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChjaGVja291dFNkaykge1xuICAgICAgICAgICAgaWYgKGNoZWNrb3V0U2RrKSB7XG4gICAgICAgICAgICAgIHNhZmVTZXRDb250ZXh0KHN0cmlwZSwgY2hlY2tvdXRTZGspO1xuICAgICAgICAgICAgICBjaGVja291dFNkay5vbignY2hhbmdlJywgc2V0U2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocGFyc2VkLnRhZyA9PT0gJ3N5bmMnICYmIHBhcnNlZC5zdHJpcGUgJiYgIWluaXRDaGVja291dENhbGxlZFJlZi5jdXJyZW50KSB7XG4gICAgICBpbml0Q2hlY2tvdXRDYWxsZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICBwYXJzZWQuc3RyaXBlLmluaXRDaGVja291dChvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChjaGVja291dFNkaykge1xuICAgICAgICBpZiAoY2hlY2tvdXRTZGspIHtcbiAgICAgICAgICBzYWZlU2V0Q29udGV4dChwYXJzZWQuc3RyaXBlLCBjaGVja291dFNkayk7XG4gICAgICAgICAgY2hlY2tvdXRTZGsub24oJ2NoYW5nZScsIHNldFNlc3Npb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaXNNb3VudGVkID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW3BhcnNlZCwgY3R4LCBvcHRpb25zLCBzZXRTZXNzaW9uXSk7IC8vIFdhcm4gb24gY2hhbmdlcyB0byBzdHJpcGUgcHJvcFxuXG4gIHZhciBwcmV2U3RyaXBlID0gdXNlUHJldmlvdXMocmF3U3RyaXBlUHJvcCk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByZXZTdHJpcGUgIT09IG51bGwgJiYgcHJldlN0cmlwZSAhPT0gcmF3U3RyaXBlUHJvcCkge1xuICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCBwcm9wIGNoYW5nZSBvbiBDaGVja291dFByb3ZpZGVyOiBZb3UgY2Fubm90IGNoYW5nZSB0aGUgYHN0cmlwZWAgcHJvcCBhZnRlciBzZXR0aW5nIGl0LicpO1xuICAgIH1cbiAgfSwgW3ByZXZTdHJpcGUsIHJhd1N0cmlwZVByb3BdKTsgLy8gQXBwbHkgdXBkYXRlcyB0byBlbGVtZW50cyB3aGVuIG9wdGlvbnMgcHJvcCBoYXMgcmVsZXZhbnQgY2hhbmdlc1xuXG4gIHZhciBwcmV2T3B0aW9ucyA9IHVzZVByZXZpb3VzKG9wdGlvbnMpO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcHJldk9wdGlvbnMkZWxlbWVudHMsIF9vcHRpb25zJGVsZW1lbnRzT3B0aTtcblxuICAgIGlmICghY3R4LmNoZWNrb3V0U2RrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzQXBwZWFyYW5jZSA9IHByZXZPcHRpb25zID09PSBudWxsIHx8IHByZXZPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3ByZXZPcHRpb25zJGVsZW1lbnRzID0gcHJldk9wdGlvbnMuZWxlbWVudHNPcHRpb25zKSA9PT0gbnVsbCB8fCBfcHJldk9wdGlvbnMkZWxlbWVudHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wcmV2T3B0aW9ucyRlbGVtZW50cy5hcHBlYXJhbmNlO1xuICAgIHZhciBjdXJyZW50QXBwZWFyYW5jZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9vcHRpb25zJGVsZW1lbnRzT3B0aSA9IG9wdGlvbnMuZWxlbWVudHNPcHRpb25zKSA9PT0gbnVsbCB8fCBfb3B0aW9ucyRlbGVtZW50c09wdGkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb25zJGVsZW1lbnRzT3B0aS5hcHBlYXJhbmNlO1xuXG4gICAgaWYgKGN1cnJlbnRBcHBlYXJhbmNlICYmICFpc0VxdWFsKGN1cnJlbnRBcHBlYXJhbmNlLCBwcmV2aW91c0FwcGVhcmFuY2UpKSB7XG4gICAgICBjdHguY2hlY2tvdXRTZGsuY2hhbmdlQXBwZWFyYW5jZShjdXJyZW50QXBwZWFyYW5jZSk7XG4gICAgfVxuICB9LCBbb3B0aW9ucywgcHJldk9wdGlvbnMsIGN0eC5jaGVja291dFNka10pOyAvLyBBdHRhY2ggcmVhY3Qtc3RyaXBlLWpzIHZlcnNpb24gdG8gc3RyaXBlLmpzIGluc3RhbmNlXG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZWdpc3RlcldpdGhTdHJpcGVKcyhjdHguc3RyaXBlKTtcbiAgfSwgW2N0eC5zdHJpcGVdKTtcbiAgdmFyIGNoZWNrb3V0Q29udGV4dFZhbHVlID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGV4dHJhY3RDaGVja291dENvbnRleHRWYWx1ZShjdHguY2hlY2tvdXRTZGssIHNlc3Npb24pO1xuICB9LCBbY3R4LmNoZWNrb3V0U2RrLCBzZXNzaW9uXSk7XG5cbiAgaWYgKCFjdHguY2hlY2tvdXRTZGspIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDaGVja291dFNka0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY3R4XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENoZWNrb3V0Q29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjaGVja291dENvbnRleHRWYWx1ZVxuICB9LCBjaGlsZHJlbikpO1xufTtcbkNoZWNrb3V0UHJvdmlkZXIucHJvcFR5cGVzID0ge1xuICBzdHJpcGU6IFByb3BUeXBlcy5hbnksXG4gIG9wdGlvbnM6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgZmV0Y2hDbGllbnRTZWNyZXQ6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgZWxlbWVudHNPcHRpb25zOiBQcm9wVHlwZXMub2JqZWN0XG4gIH0pLmlzUmVxdWlyZWRcbn07XG52YXIgdXNlQ2hlY2tvdXRTZGtDb250ZXh0V2l0aFVzZUNhc2UgPSBmdW5jdGlvbiB1c2VDaGVja291dFNka0NvbnRleHRXaXRoVXNlQ2FzZSh1c2VDYXNlU3RyaW5nKSB7XG4gIHZhciBjdHggPSBSZWFjdC51c2VDb250ZXh0KENoZWNrb3V0U2RrQ29udGV4dCk7XG4gIHJldHVybiBwYXJzZUNoZWNrb3V0U2RrQ29udGV4dChjdHgsIHVzZUNhc2VTdHJpbmcpO1xufTtcbnZhciB1c2VFbGVtZW50c09yQ2hlY2tvdXRTZGtDb250ZXh0V2l0aFVzZUNhc2UgPSBmdW5jdGlvbiB1c2VFbGVtZW50c09yQ2hlY2tvdXRTZGtDb250ZXh0V2l0aFVzZUNhc2UodXNlQ2FzZVN0cmluZykge1xuICB2YXIgY2hlY2tvdXRTZGtDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChDaGVja291dFNka0NvbnRleHQpO1xuICB2YXIgZWxlbWVudHNDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChFbGVtZW50c0NvbnRleHQpO1xuXG4gIGlmIChjaGVja291dFNka0NvbnRleHQgJiYgZWxlbWVudHNDb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCB3cmFwIHRoZSBwYXJ0IG9mIHlvdXIgYXBwIHRoYXQgXCIuY29uY2F0KHVzZUNhc2VTdHJpbmcsIFwiIGluIGJvdGggPENoZWNrb3V0UHJvdmlkZXI+IGFuZCA8RWxlbWVudHM+IHByb3ZpZGVycy5cIikpO1xuICB9XG5cbiAgaWYgKGNoZWNrb3V0U2RrQ29udGV4dCkge1xuICAgIHJldHVybiBwYXJzZUNoZWNrb3V0U2RrQ29udGV4dChjaGVja291dFNka0NvbnRleHQsIHVzZUNhc2VTdHJpbmcpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlRWxlbWVudHNDb250ZXh0KGVsZW1lbnRzQ29udGV4dCwgdXNlQ2FzZVN0cmluZyk7XG59O1xudmFyIHVzZUNoZWNrb3V0ID0gZnVuY3Rpb24gdXNlQ2hlY2tvdXQoKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGluIENoZWNrb3V0UHJvdmlkZXJcbiAgdXNlQ2hlY2tvdXRTZGtDb250ZXh0V2l0aFVzZUNhc2UoJ2NhbGxzIHVzZUNoZWNrb3V0KCknKTtcbiAgdmFyIGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoQ2hlY2tvdXRDb250ZXh0KTtcblxuICBpZiAoIWN0eCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgQ2hlY2tvdXQgQ29udGV4dDsgWW91IG5lZWQgdG8gd3JhcCB0aGUgcGFydCBvZiB5b3VyIGFwcCB0aGF0IGNhbGxzIHVzZUNoZWNrb3V0KCkgaW4gYW4gPENoZWNrb3V0UHJvdmlkZXI+IHByb3ZpZGVyLicpO1xuICB9XG5cbiAgcmV0dXJuIGN0eDtcbn07XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJtb2RlXCJdO1xuXG52YXIgY2FwaXRhbGl6ZWQgPSBmdW5jdGlvbiBjYXBpdGFsaXplZChzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn07XG5cbnZhciBjcmVhdGVFbGVtZW50Q29tcG9uZW50ID0gZnVuY3Rpb24gY3JlYXRlRWxlbWVudENvbXBvbmVudCh0eXBlLCBpc1NlcnZlcikge1xuICB2YXIgZGlzcGxheU5hbWUgPSBcIlwiLmNvbmNhdChjYXBpdGFsaXplZCh0eXBlKSwgXCJFbGVtZW50XCIpO1xuXG4gIHZhciBDbGllbnRFbGVtZW50ID0gZnVuY3Rpb24gQ2xpZW50RWxlbWVudChfcmVmKSB7XG4gICAgdmFyIGlkID0gX3JlZi5pZCxcbiAgICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICAgIF9yZWYkb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgICAgb3B0aW9ucyA9IF9yZWYkb3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfcmVmJG9wdGlvbnMsXG4gICAgICAgIG9uQmx1ciA9IF9yZWYub25CbHVyLFxuICAgICAgICBvbkZvY3VzID0gX3JlZi5vbkZvY3VzLFxuICAgICAgICBvblJlYWR5ID0gX3JlZi5vblJlYWR5LFxuICAgICAgICBvbkNoYW5nZSA9IF9yZWYub25DaGFuZ2UsXG4gICAgICAgIG9uRXNjYXBlID0gX3JlZi5vbkVzY2FwZSxcbiAgICAgICAgb25DbGljayA9IF9yZWYub25DbGljayxcbiAgICAgICAgb25Mb2FkRXJyb3IgPSBfcmVmLm9uTG9hZEVycm9yLFxuICAgICAgICBvbkxvYWRlclN0YXJ0ID0gX3JlZi5vbkxvYWRlclN0YXJ0LFxuICAgICAgICBvbk5ldHdvcmtzQ2hhbmdlID0gX3JlZi5vbk5ldHdvcmtzQ2hhbmdlLFxuICAgICAgICBvbkNvbmZpcm0gPSBfcmVmLm9uQ29uZmlybSxcbiAgICAgICAgb25DYW5jZWwgPSBfcmVmLm9uQ2FuY2VsLFxuICAgICAgICBvblNoaXBwaW5nQWRkcmVzc0NoYW5nZSA9IF9yZWYub25TaGlwcGluZ0FkZHJlc3NDaGFuZ2UsXG4gICAgICAgIG9uU2hpcHBpbmdSYXRlQ2hhbmdlID0gX3JlZi5vblNoaXBwaW5nUmF0ZUNoYW5nZTtcbiAgICB2YXIgY3R4ID0gdXNlRWxlbWVudHNPckNoZWNrb3V0U2RrQ29udGV4dFdpdGhVc2VDYXNlKFwibW91bnRzIDxcIi5jb25jYXQoZGlzcGxheU5hbWUsIFwiPlwiKSk7XG4gICAgdmFyIGVsZW1lbnRzID0gJ2VsZW1lbnRzJyBpbiBjdHggPyBjdHguZWxlbWVudHMgOiBudWxsO1xuICAgIHZhciBjaGVja291dFNkayA9ICdjaGVja291dFNkaycgaW4gY3R4ID8gY3R4LmNoZWNrb3V0U2RrIDogbnVsbDtcblxuICAgIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShudWxsKSxcbiAgICAgICAgX1JlYWN0JHVzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF9SZWFjdCR1c2VTdGF0ZSwgMiksXG4gICAgICAgIGVsZW1lbnQgPSBfUmVhY3QkdXNlU3RhdGUyWzBdLFxuICAgICAgICBzZXRFbGVtZW50ID0gX1JlYWN0JHVzZVN0YXRlMlsxXTtcblxuICAgIHZhciBlbGVtZW50UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIHZhciBkb21Ob2RlID0gUmVhY3QudXNlUmVmKG51bGwpOyAvLyBGb3IgZXZlcnkgZXZlbnQgd2hlcmUgdGhlIG1lcmNoYW50IHByb3ZpZGVzIGEgY2FsbGJhY2ssIGNhbGwgZWxlbWVudC5vblxuICAgIC8vIHdpdGggdGhhdCBjYWxsYmFjay4gSWYgdGhlIG1lcmNoYW50IGV2ZXIgY2hhbmdlcyB0aGUgY2FsbGJhY2ssIHJlbW92ZXNcbiAgICAvLyB0aGUgb2xkIGNhbGxiYWNrIHdpdGggZWxlbWVudC5vZmYgYW5kIHRoZW4gY2FsbCBlbGVtZW50Lm9uIHdpdGggdGhlIG5ldyBvbmUuXG5cbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnYmx1cicsIG9uQmx1cik7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ2ZvY3VzJywgb25Gb2N1cyk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ2VzY2FwZScsIG9uRXNjYXBlKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnY2xpY2snLCBvbkNsaWNrKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnbG9hZGVycm9yJywgb25Mb2FkRXJyb3IpO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdsb2FkZXJzdGFydCcsIG9uTG9hZGVyU3RhcnQpO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICduZXR3b3Jrc2NoYW5nZScsIG9uTmV0d29ya3NDaGFuZ2UpO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdjb25maXJtJywgb25Db25maXJtKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnY2FuY2VsJywgb25DYW5jZWwpO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdzaGlwcGluZ2FkZHJlc3NjaGFuZ2UnLCBvblNoaXBwaW5nQWRkcmVzc0NoYW5nZSk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ3NoaXBwaW5ncmF0ZWNoYW5nZScsIG9uU2hpcHBpbmdSYXRlQ2hhbmdlKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgIHZhciByZWFkeUNhbGxiYWNrO1xuXG4gICAgaWYgKG9uUmVhZHkpIHtcbiAgICAgIGlmICh0eXBlID09PSAnZXhwcmVzc0NoZWNrb3V0Jykge1xuICAgICAgICAvLyBQYXNzZXMgdGhyb3VnaCB0aGUgZXZlbnQsIHdoaWNoIGluY2x1ZGVzIHZpc2libGUgUE0gdHlwZXNcbiAgICAgICAgcmVhZHlDYWxsYmFjayA9IG9uUmVhZHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb3RoZXIgRWxlbWVudHMsIHBhc3MgdGhyb3VnaCB0aGUgRWxlbWVudCBpdHNlbGYuXG4gICAgICAgIHJlYWR5Q2FsbGJhY2sgPSBmdW5jdGlvbiByZWFkeUNhbGxiYWNrKCkge1xuICAgICAgICAgIG9uUmVhZHkoZWxlbWVudCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ3JlYWR5JywgcmVhZHlDYWxsYmFjayk7XG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChlbGVtZW50UmVmLmN1cnJlbnQgPT09IG51bGwgJiYgZG9tTm9kZS5jdXJyZW50ICE9PSBudWxsICYmIChlbGVtZW50cyB8fCBjaGVja291dFNkaykpIHtcbiAgICAgICAgdmFyIG5ld0VsZW1lbnQgPSBudWxsO1xuXG4gICAgICAgIGlmIChjaGVja291dFNkaykge1xuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAncGF5bWVudCc6XG4gICAgICAgICAgICAgIG5ld0VsZW1lbnQgPSBjaGVja291dFNkay5jcmVhdGVQYXltZW50RWxlbWVudChvcHRpb25zKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgICAgICAgICBpZiAoJ21vZGUnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9kZSA9IG9wdGlvbnMubW9kZSxcbiAgICAgICAgICAgICAgICAgICAgcmVzdE9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob3B0aW9ucywgX2V4Y2x1ZGVkKTtcblxuICAgICAgICAgICAgICAgIGlmIChtb2RlID09PSAnc2hpcHBpbmcnKSB7XG4gICAgICAgICAgICAgICAgICBuZXdFbGVtZW50ID0gY2hlY2tvdXRTZGsuY3JlYXRlU2hpcHBpbmdBZGRyZXNzRWxlbWVudChyZXN0T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnYmlsbGluZycpIHtcbiAgICAgICAgICAgICAgICAgIG5ld0VsZW1lbnQgPSBjaGVja291dFNkay5jcmVhdGVCaWxsaW5nQWRkcmVzc0VsZW1lbnQocmVzdE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG9wdGlvbnMubW9kZS4gbW9kZSBtdXN0IGJlICdiaWxsaW5nJyBvciAnc2hpcHBpbmcnLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3Qgc3VwcGx5IG9wdGlvbnMubW9kZS4gbW9kZSBtdXN0IGJlICdiaWxsaW5nJyBvciAnc2hpcHBpbmcnLlwiKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdleHByZXNzQ2hlY2tvdXQnOlxuICAgICAgICAgICAgICBuZXdFbGVtZW50ID0gY2hlY2tvdXRTZGsuY3JlYXRlRXhwcmVzc0NoZWNrb3V0RWxlbWVudChvcHRpb25zKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2N1cnJlbmN5U2VsZWN0b3InOlxuICAgICAgICAgICAgICBuZXdFbGVtZW50ID0gY2hlY2tvdXRTZGsuY3JlYXRlQ3VycmVuY3lTZWxlY3RvckVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgRWxlbWVudCB0eXBlIFwiLmNvbmNhdChkaXNwbGF5TmFtZSwgXCIuIFlvdSBtdXN0IHVzZSBlaXRoZXIgdGhlIDxQYXltZW50RWxlbWVudCAvPiwgPEFkZHJlc3NFbGVtZW50IG9wdGlvbnM9e3ttb2RlOiAnc2hpcHBpbmcnfX0gLz4sIDxBZGRyZXNzRWxlbWVudCBvcHRpb25zPXt7bW9kZTogJ2JpbGxpbmcnfX0gLz4sIG9yIDxFeHByZXNzQ2hlY2tvdXRFbGVtZW50IC8+LlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgbmV3RWxlbWVudCA9IGVsZW1lbnRzLmNyZWF0ZSh0eXBlLCBvcHRpb25zKTtcbiAgICAgICAgfSAvLyBTdG9yZSBlbGVtZW50IGluIGEgcmVmIHRvIGVuc3VyZSBpdCdzIF9pbW1lZGlhdGVseV8gYXZhaWxhYmxlIGluIGNsZWFudXAgaG9va3MgaW4gU3RyaWN0TW9kZVxuXG5cbiAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50ID0gbmV3RWxlbWVudDsgLy8gU3RvcmUgZWxlbWVudCBpbiBzdGF0ZSB0byBmYWNpbGl0YXRlIGV2ZW50IGxpc3RlbmVyIGF0dGFjaG1lbnRcblxuICAgICAgICBzZXRFbGVtZW50KG5ld0VsZW1lbnQpO1xuXG4gICAgICAgIGlmIChuZXdFbGVtZW50KSB7XG4gICAgICAgICAgbmV3RWxlbWVudC5tb3VudChkb21Ob2RlLmN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW2VsZW1lbnRzLCBjaGVja291dFNkaywgb3B0aW9uc10pO1xuICAgIHZhciBwcmV2T3B0aW9ucyA9IHVzZVByZXZpb3VzKG9wdGlvbnMpO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWVsZW1lbnRSZWYuY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB1cGRhdGVzID0gZXh0cmFjdEFsbG93ZWRPcHRpb25zVXBkYXRlcyhvcHRpb25zLCBwcmV2T3B0aW9ucywgWydwYXltZW50UmVxdWVzdCddKTtcblxuICAgICAgaWYgKHVwZGF0ZXMgJiYgJ3VwZGF0ZScgaW4gZWxlbWVudFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGVsZW1lbnRSZWYuY3VycmVudC51cGRhdGUodXBkYXRlcyk7XG4gICAgICB9XG4gICAgfSwgW29wdGlvbnMsIHByZXZPcHRpb25zXSk7XG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChlbGVtZW50UmVmLmN1cnJlbnQgJiYgdHlwZW9mIGVsZW1lbnRSZWYuY3VycmVudC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVsZW1lbnRSZWYuY3VycmVudC5kZXN0cm95KCk7XG4gICAgICAgICAgICBlbGVtZW50UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7Ly8gRG8gbm90aGluZ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgcmVmOiBkb21Ob2RlXG4gICAgfSk7XG4gIH07IC8vIE9ubHkgcmVuZGVyIHRoZSBFbGVtZW50IHdyYXBwZXIgaW4gYSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG5cblxuICB2YXIgU2VydmVyRWxlbWVudCA9IGZ1bmN0aW9uIFNlcnZlckVsZW1lbnQocHJvcHMpIHtcbiAgICB1c2VFbGVtZW50c09yQ2hlY2tvdXRTZGtDb250ZXh0V2l0aFVzZUNhc2UoXCJtb3VudHMgPFwiLmNvbmNhdChkaXNwbGF5TmFtZSwgXCI+XCIpKTtcbiAgICB2YXIgaWQgPSBwcm9wcy5pZCxcbiAgICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBpZDogaWQsXG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBFbGVtZW50ID0gaXNTZXJ2ZXIgPyBTZXJ2ZXJFbGVtZW50IDogQ2xpZW50RWxlbWVudDtcbiAgRWxlbWVudC5wcm9wVHlwZXMgPSB7XG4gICAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkJsdXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uRm9jdXM6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uUmVhZHk6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uRXNjYXBlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkxvYWRFcnJvcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Mb2FkZXJTdGFydDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25OZXR3b3Jrc0NoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Db25maXJtOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNhbmNlbDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25TaGlwcGluZ0FkZHJlc3NDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uU2hpcHBpbmdSYXRlQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvcHRpb25zOiBQcm9wVHlwZXMub2JqZWN0XG4gIH07XG4gIEVsZW1lbnQuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgRWxlbWVudC5fX2VsZW1lbnRUeXBlID0gdHlwZTtcbiAgcmV0dXJuIEVsZW1lbnQ7XG59O1xuXG52YXIgaXNTZXJ2ZXIgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJztcblxudmFyIEVtYmVkZGVkQ2hlY2tvdXRDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5FbWJlZGRlZENoZWNrb3V0Q29udGV4dC5kaXNwbGF5TmFtZSA9ICdFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXJDb250ZXh0JztcbnZhciB1c2VFbWJlZGRlZENoZWNrb3V0Q29udGV4dCA9IGZ1bmN0aW9uIHVzZUVtYmVkZGVkQ2hlY2tvdXRDb250ZXh0KCkge1xuICB2YXIgY3R4ID0gUmVhY3QudXNlQ29udGV4dChFbWJlZGRlZENoZWNrb3V0Q29udGV4dCk7XG5cbiAgaWYgKCFjdHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJzxFbWJlZGRlZENoZWNrb3V0PiBtdXN0IGJlIHVzZWQgd2l0aGluIDxFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXI+Jyk7XG4gIH1cblxuICByZXR1cm4gY3R4O1xufTtcbnZhciBJTlZBTElEX1NUUklQRV9FUlJPUiA9ICdJbnZhbGlkIHByb3AgYHN0cmlwZWAgc3VwcGxpZWQgdG8gYEVtYmVkZGVkQ2hlY2tvdXRQcm92aWRlcmAuIFdlIHJlY29tbWVuZCB1c2luZyB0aGUgYGxvYWRTdHJpcGVgIHV0aWxpdHkgZnJvbSBgQHN0cmlwZS9zdHJpcGUtanNgLiBTZWUgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnRzLXByb3BzLXN0cmlwZSBmb3IgZGV0YWlscy4nO1xudmFyIEVtYmVkZGVkQ2hlY2tvdXRQcm92aWRlciA9IGZ1bmN0aW9uIEVtYmVkZGVkQ2hlY2tvdXRQcm92aWRlcihfcmVmKSB7XG4gIHZhciByYXdTdHJpcGVQcm9wID0gX3JlZi5zdHJpcGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICB2YXIgcGFyc2VkID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBhcnNlU3RyaXBlUHJvcChyYXdTdHJpcGVQcm9wLCBJTlZBTElEX1NUUklQRV9FUlJPUik7XG4gIH0sIFtyYXdTdHJpcGVQcm9wXSk7XG4gIHZhciBlbWJlZGRlZENoZWNrb3V0UHJvbWlzZSA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdmFyIGxvYWRlZFN0cmlwZSA9IFJlYWN0LnVzZVJlZihudWxsKTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIGVtYmVkZGVkQ2hlY2tvdXQ6IG51bGxcbiAgfSksXG4gICAgICBfUmVhY3QkdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlLCAyKSxcbiAgICAgIGN0eCA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRDb250ZXh0ID0gX1JlYWN0JHVzZVN0YXRlMlsxXTtcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIC8vIERvbid0IHN1cHBvcnQgYW55IGN0eCB1cGRhdGVzIG9uY2UgZW1iZWRkZWRDaGVja291dCBvciBzdHJpcGUgaXMgc2V0LlxuICAgIGlmIChsb2FkZWRTdHJpcGUuY3VycmVudCB8fCBlbWJlZGRlZENoZWNrb3V0UHJvbWlzZS5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNldFN0cmlwZUFuZEluaXRFbWJlZGRlZENoZWNrb3V0ID0gZnVuY3Rpb24gc2V0U3RyaXBlQW5kSW5pdEVtYmVkZGVkQ2hlY2tvdXQoc3RyaXBlKSB7XG4gICAgICBpZiAobG9hZGVkU3RyaXBlLmN1cnJlbnQgfHwgZW1iZWRkZWRDaGVja291dFByb21pc2UuY3VycmVudCkgcmV0dXJuO1xuICAgICAgbG9hZGVkU3RyaXBlLmN1cnJlbnQgPSBzdHJpcGU7XG4gICAgICBlbWJlZGRlZENoZWNrb3V0UHJvbWlzZS5jdXJyZW50ID0gbG9hZGVkU3RyaXBlLmN1cnJlbnQuaW5pdEVtYmVkZGVkQ2hlY2tvdXQob3B0aW9ucykudGhlbihmdW5jdGlvbiAoZW1iZWRkZWRDaGVja291dCkge1xuICAgICAgICBzZXRDb250ZXh0KHtcbiAgICAgICAgICBlbWJlZGRlZENoZWNrb3V0OiBlbWJlZGRlZENoZWNrb3V0XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTsgLy8gRm9yIGFuIGFzeW5jIHN0cmlwZVByb21pc2UsIHN0b3JlIGl0IG9uY2UgcmVzb2x2ZWRcblxuXG4gICAgaWYgKHBhcnNlZC50YWcgPT09ICdhc3luYycgJiYgIWxvYWRlZFN0cmlwZS5jdXJyZW50ICYmIChvcHRpb25zLmNsaWVudFNlY3JldCB8fCBvcHRpb25zLmZldGNoQ2xpZW50U2VjcmV0KSkge1xuICAgICAgcGFyc2VkLnN0cmlwZVByb21pc2UudGhlbihmdW5jdGlvbiAoc3RyaXBlKSB7XG4gICAgICAgIGlmIChzdHJpcGUpIHtcbiAgICAgICAgICBzZXRTdHJpcGVBbmRJbml0RW1iZWRkZWRDaGVja291dChzdHJpcGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHBhcnNlZC50YWcgPT09ICdzeW5jJyAmJiAhbG9hZGVkU3RyaXBlLmN1cnJlbnQgJiYgKG9wdGlvbnMuY2xpZW50U2VjcmV0IHx8IG9wdGlvbnMuZmV0Y2hDbGllbnRTZWNyZXQpKSB7XG4gICAgICAvLyBPciwgaGFuZGxlIGEgc3luYyBzdHJpcGUgaW5zdGFuY2UgZ29pbmcgZnJvbSBudWxsIC0+IHBvcHVsYXRlZFxuICAgICAgc2V0U3RyaXBlQW5kSW5pdEVtYmVkZGVkQ2hlY2tvdXQocGFyc2VkLnN0cmlwZSk7XG4gICAgfVxuICB9LCBbcGFyc2VkLCBvcHRpb25zLCBjdHgsIGxvYWRlZFN0cmlwZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIC8vIGNsZWFudXAgb24gdW5tb3VudFxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBJZiBlbWJlZGRlZCBjaGVja291dCBpcyBmdWxseSBpbml0aWFsaXplZCwgZGVzdHJveSBpdC5cbiAgICAgIGlmIChjdHguZW1iZWRkZWRDaGVja291dCkge1xuICAgICAgICBlbWJlZGRlZENoZWNrb3V0UHJvbWlzZS5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgY3R4LmVtYmVkZGVkQ2hlY2tvdXQuZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIGlmIChlbWJlZGRlZENoZWNrb3V0UHJvbWlzZS5jdXJyZW50KSB7XG4gICAgICAgIC8vIElmIGVtYmVkZGVkIGNoZWNrb3V0IGlzIHN0aWxsIGluaXRpYWxpemluZywgZGVzdHJveSBpdCBvbmNlXG4gICAgICAgIC8vIGl0J3MgZG9uZS4gVGhpcyBjb3VsZCBiZSBjYXVzZWQgYnkgdW5tb3VudGluZyB2ZXJ5IHF1aWNrbHlcbiAgICAgICAgLy8gYWZ0ZXIgbW91bnRpbmcuXG4gICAgICAgIGVtYmVkZGVkQ2hlY2tvdXRQcm9taXNlLmN1cnJlbnQudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZW1iZWRkZWRDaGVja291dFByb21pc2UuY3VycmVudCA9IG51bGw7XG5cbiAgICAgICAgICBpZiAoY3R4LmVtYmVkZGVkQ2hlY2tvdXQpIHtcbiAgICAgICAgICAgIGN0eC5lbWJlZGRlZENoZWNrb3V0LmRlc3Ryb3koKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtjdHguZW1iZWRkZWRDaGVja291dF0pOyAvLyBBdHRhY2ggcmVhY3Qtc3RyaXBlLWpzIHZlcnNpb24gdG8gc3RyaXBlLmpzIGluc3RhbmNlXG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZWdpc3RlcldpdGhTdHJpcGVKcyhsb2FkZWRTdHJpcGUpO1xuICB9LCBbbG9hZGVkU3RyaXBlXSk7IC8vIFdhcm4gb24gY2hhbmdlcyB0byBzdHJpcGUgcHJvcC5cbiAgLy8gVGhlIHN0cmlwZSBwcm9wIHZhbHVlIGNhbiBvbmx5IGdvIGZyb20gbnVsbCB0byBub24tbnVsbCBvbmNlIGFuZFxuICAvLyBjYW4ndCBiZSBjaGFuZ2VkIGFmdGVyIHRoYXQuXG5cbiAgdmFyIHByZXZTdHJpcGUgPSB1c2VQcmV2aW91cyhyYXdTdHJpcGVQcm9wKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocHJldlN0cmlwZSAhPT0gbnVsbCAmJiBwcmV2U3RyaXBlICE9PSByYXdTdHJpcGVQcm9wKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1Vuc3VwcG9ydGVkIHByb3AgY2hhbmdlIG9uIEVtYmVkZGVkQ2hlY2tvdXRQcm92aWRlcjogWW91IGNhbm5vdCBjaGFuZ2UgdGhlIGBzdHJpcGVgIHByb3AgYWZ0ZXIgc2V0dGluZyBpdC4nKTtcbiAgICB9XG4gIH0sIFtwcmV2U3RyaXBlLCByYXdTdHJpcGVQcm9wXSk7IC8vIFdhcm4gb24gY2hhbmdlcyB0byBvcHRpb25zLlxuXG4gIHZhciBwcmV2T3B0aW9ucyA9IHVzZVByZXZpb3VzKG9wdGlvbnMpO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChwcmV2T3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCBwcm9wIGNoYW5nZSBvbiBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXI6IFlvdSBjYW5ub3QgdW5zZXQgb3B0aW9ucyBhZnRlciBzZXR0aW5nIHRoZW0uJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuY2xpZW50U2VjcmV0ID09PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5mZXRjaENsaWVudFNlY3JldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgcHJvcHMgcGFzc2VkIHRvIEVtYmVkZGVkQ2hlY2tvdXRQcm92aWRlcjogWW91IG11c3QgcHJvdmlkZSBvbmUgb2YgZWl0aGVyIGBvcHRpb25zLmZldGNoQ2xpZW50U2VjcmV0YCBvciBgb3B0aW9ucy5jbGllbnRTZWNyZXRgLicpO1xuICAgIH1cblxuICAgIGlmIChwcmV2T3B0aW9ucy5jbGllbnRTZWNyZXQgIT0gbnVsbCAmJiBvcHRpb25zLmNsaWVudFNlY3JldCAhPT0gcHJldk9wdGlvbnMuY2xpZW50U2VjcmV0KSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1Vuc3VwcG9ydGVkIHByb3AgY2hhbmdlIG9uIEVtYmVkZGVkQ2hlY2tvdXRQcm92aWRlcjogWW91IGNhbm5vdCBjaGFuZ2UgdGhlIGNsaWVudCBzZWNyZXQgYWZ0ZXIgc2V0dGluZyBpdC4gVW5tb3VudCBhbmQgY3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEVtYmVkZGVkQ2hlY2tvdXRQcm92aWRlciBpbnN0ZWFkLicpO1xuICAgIH1cblxuICAgIGlmIChwcmV2T3B0aW9ucy5mZXRjaENsaWVudFNlY3JldCAhPSBudWxsICYmIG9wdGlvbnMuZmV0Y2hDbGllbnRTZWNyZXQgIT09IHByZXZPcHRpb25zLmZldGNoQ2xpZW50U2VjcmV0KSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1Vuc3VwcG9ydGVkIHByb3AgY2hhbmdlIG9uIEVtYmVkZGVkQ2hlY2tvdXRQcm92aWRlcjogWW91IGNhbm5vdCBjaGFuZ2UgZmV0Y2hDbGllbnRTZWNyZXQgYWZ0ZXIgc2V0dGluZyBpdC4gVW5tb3VudCBhbmQgY3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEVtYmVkZGVkQ2hlY2tvdXRQcm92aWRlciBpbnN0ZWFkLicpO1xuICAgIH1cblxuICAgIGlmIChwcmV2T3B0aW9ucy5vbkNvbXBsZXRlICE9IG51bGwgJiYgb3B0aW9ucy5vbkNvbXBsZXRlICE9PSBwcmV2T3B0aW9ucy5vbkNvbXBsZXRlKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1Vuc3VwcG9ydGVkIHByb3AgY2hhbmdlIG9uIEVtYmVkZGVkQ2hlY2tvdXRQcm92aWRlcjogWW91IGNhbm5vdCBjaGFuZ2UgdGhlIG9uQ29tcGxldGUgb3B0aW9uIGFmdGVyIHNldHRpbmcgaXQuJyk7XG4gICAgfVxuXG4gICAgaWYgKHByZXZPcHRpb25zLm9uU2hpcHBpbmdEZXRhaWxzQ2hhbmdlICE9IG51bGwgJiYgb3B0aW9ucy5vblNoaXBwaW5nRGV0YWlsc0NoYW5nZSAhPT0gcHJldk9wdGlvbnMub25TaGlwcGluZ0RldGFpbHNDaGFuZ2UpIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5zdXBwb3J0ZWQgcHJvcCBjaGFuZ2Ugb24gRW1iZWRkZWRDaGVja291dFByb3ZpZGVyOiBZb3UgY2Fubm90IGNoYW5nZSB0aGUgb25TaGlwcGluZ0RldGFpbHNDaGFuZ2Ugb3B0aW9uIGFmdGVyIHNldHRpbmcgaXQuJyk7XG4gICAgfVxuXG4gICAgaWYgKHByZXZPcHRpb25zLm9uTGluZUl0ZW1zQ2hhbmdlICE9IG51bGwgJiYgb3B0aW9ucy5vbkxpbmVJdGVtc0NoYW5nZSAhPT0gcHJldk9wdGlvbnMub25MaW5lSXRlbXNDaGFuZ2UpIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5zdXBwb3J0ZWQgcHJvcCBjaGFuZ2Ugb24gRW1iZWRkZWRDaGVja291dFByb3ZpZGVyOiBZb3UgY2Fubm90IGNoYW5nZSB0aGUgb25MaW5lSXRlbXNDaGFuZ2Ugb3B0aW9uIGFmdGVyIHNldHRpbmcgaXQuJyk7XG4gICAgfVxuICB9LCBbcHJldk9wdGlvbnMsIG9wdGlvbnNdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVtYmVkZGVkQ2hlY2tvdXRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGN0eFxuICB9LCBjaGlsZHJlbik7XG59O1xuXG52YXIgRW1iZWRkZWRDaGVja291dENsaWVudEVsZW1lbnQgPSBmdW5jdGlvbiBFbWJlZGRlZENoZWNrb3V0Q2xpZW50RWxlbWVudChfcmVmKSB7XG4gIHZhciBpZCA9IF9yZWYuaWQsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZTtcblxuICB2YXIgX3VzZUVtYmVkZGVkQ2hlY2tvdXRDID0gdXNlRW1iZWRkZWRDaGVja291dENvbnRleHQoKSxcbiAgICAgIGVtYmVkZGVkQ2hlY2tvdXQgPSBfdXNlRW1iZWRkZWRDaGVja291dEMuZW1iZWRkZWRDaGVja291dDtcblxuICB2YXIgaXNNb3VudGVkID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgdmFyIGRvbU5vZGUgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFpc01vdW50ZWQuY3VycmVudCAmJiBlbWJlZGRlZENoZWNrb3V0ICYmIGRvbU5vZGUuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgZW1iZWRkZWRDaGVja291dC5tb3VudChkb21Ob2RlLmN1cnJlbnQpO1xuICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgIH0gLy8gQ2xlYW4gdXAgb24gdW5tb3VudFxuXG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzTW91bnRlZC5jdXJyZW50ICYmIGVtYmVkZGVkQ2hlY2tvdXQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBlbWJlZGRlZENoZWNrb3V0LnVubW91bnQoKTtcbiAgICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9IGNhdGNoIChlKSB7Ly8gRG8gbm90aGluZy5cbiAgICAgICAgICAvLyBQYXJlbnQgZWZmZWN0cyBhcmUgZGVzdHJveWVkIGJlZm9yZSBjaGlsZCBlZmZlY3RzLCBzb1xuICAgICAgICAgIC8vIGluIGNhc2VzIHdoZXJlIGJvdGggdGhlIEVtYmVkZGVkQ2hlY2tvdXRQcm92aWRlciBhbmRcbiAgICAgICAgICAvLyB0aGUgRW1iZWRkZWRDaGVja291dCBjb21wb25lbnQgYXJlIHJlbW92ZWQgYXQgdGhlIHNhbWVcbiAgICAgICAgICAvLyB0aW1lLCB0aGUgZW1iZWRkZWRDaGVja291dCBpbnN0YW5jZSB3aWxsIGJlIGRlc3Ryb3llZCxcbiAgICAgICAgICAvLyB3aGljaCBjYXVzZXMgYW4gZXJyb3Igd2hlbiBjYWxsaW5nIHVubW91bnQuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZW1iZWRkZWRDaGVja291dF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHJlZjogZG9tTm9kZSxcbiAgICBpZDogaWQsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgfSk7XG59OyAvLyBPbmx5IHJlbmRlciB0aGUgd3JhcHBlciBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cblxuXG52YXIgRW1iZWRkZWRDaGVja291dFNlcnZlckVsZW1lbnQgPSBmdW5jdGlvbiBFbWJlZGRlZENoZWNrb3V0U2VydmVyRWxlbWVudChfcmVmMikge1xuICB2YXIgaWQgPSBfcmVmMi5pZCxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZTtcbiAgLy8gVmFsaWRhdGUgdGhhdCB3ZSBhcmUgaW4gdGhlIHJpZ2h0IGNvbnRleHQgYnkgY2FsbGluZyB1c2VFbWJlZGRlZENoZWNrb3V0Q29udGV4dC5cbiAgdXNlRW1iZWRkZWRDaGVja291dENvbnRleHQoKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBpZDogaWQsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgfSk7XG59O1xuXG52YXIgRW1iZWRkZWRDaGVja291dCA9IGlzU2VydmVyID8gRW1iZWRkZWRDaGVja291dFNlcnZlckVsZW1lbnQgOiBFbWJlZGRlZENoZWNrb3V0Q2xpZW50RWxlbWVudDtcblxuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjdXNlc3RyaXBlLWhvb2tcbiAqL1xuXG52YXIgdXNlU3RyaXBlID0gZnVuY3Rpb24gdXNlU3RyaXBlKCkge1xuICB2YXIgX3VzZUVsZW1lbnRzT3JDaGVja291ID0gdXNlRWxlbWVudHNPckNoZWNrb3V0U2RrQ29udGV4dFdpdGhVc2VDYXNlKCdjYWxscyB1c2VTdHJpcGUoKScpLFxuICAgICAgc3RyaXBlID0gX3VzZUVsZW1lbnRzT3JDaGVja291LnN0cmlwZTtcblxuICByZXR1cm4gc3RyaXBlO1xufTtcblxuLyoqXG4gKiBSZXF1aXJlcyBiZXRhIGFjY2VzczpcbiAqIENvbnRhY3QgW1N0cmlwZSBzdXBwb3J0XShodHRwczovL3N1cHBvcnQuc3RyaXBlLmNvbS8pIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgQXVCYW5rQWNjb3VudEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdhdUJhbmtBY2NvdW50JywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIENhcmRFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnY2FyZCcsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBDYXJkTnVtYmVyRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2NhcmROdW1iZXInLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgQ2FyZEV4cGlyeUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdjYXJkRXhwaXJ5JywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIENhcmRDdmNFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnY2FyZEN2YycsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBGcHhCYW5rRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2ZweEJhbmsnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgSWJhbkVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdpYmFuJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIElkZWFsQmFua0VsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdpZGVhbEJhbmsnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgUDI0QmFua0VsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdwMjRCYW5rJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIEVwc0JhbmtFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnZXBzQmFuaycsIGlzU2VydmVyKTtcbnZhciBQYXltZW50RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ3BheW1lbnQnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgRXhwcmVzc0NoZWNrb3V0RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2V4cHJlc3NDaGVja291dCcsIGlzU2VydmVyKTtcbi8qKlxuICogUmVxdWlyZXMgYmV0YSBhY2Nlc3M6XG4gKiBDb250YWN0IFtTdHJpcGUgc3VwcG9ydF0oaHR0cHM6Ly9zdXBwb3J0LnN0cmlwZS5jb20vKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqL1xuXG52YXIgQ3VycmVuY3lTZWxlY3RvckVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdjdXJyZW5jeVNlbGVjdG9yJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIFBheW1lbnRSZXF1ZXN0QnV0dG9uRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ3BheW1lbnRSZXF1ZXN0QnV0dG9uJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIExpbmtBdXRoZW50aWNhdGlvbkVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdsaW5rQXV0aGVudGljYXRpb24nLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgQWRkcmVzc0VsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdhZGRyZXNzJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICogVXNlIGBBZGRyZXNzRWxlbWVudGAgaW5zdGVhZC5cbiAqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIFNoaXBwaW5nQWRkcmVzc0VsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdzaGlwcGluZ0FkZHJlc3MnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgUGF5bWVudE1ldGhvZE1lc3NhZ2luZ0VsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdwYXltZW50TWV0aG9kTWVzc2FnaW5nJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIEFmZmlybU1lc3NhZ2VFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnYWZmaXJtTWVzc2FnZScsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBBZnRlcnBheUNsZWFycGF5TWVzc2FnZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdhZnRlcnBheUNsZWFycGF5TWVzc2FnZScsIGlzU2VydmVyKTtcblxuZXhwb3J0IHsgQWRkcmVzc0VsZW1lbnQsIEFmZmlybU1lc3NhZ2VFbGVtZW50LCBBZnRlcnBheUNsZWFycGF5TWVzc2FnZUVsZW1lbnQsIEF1QmFua0FjY291bnRFbGVtZW50LCBDYXJkQ3ZjRWxlbWVudCwgQ2FyZEVsZW1lbnQsIENhcmRFeHBpcnlFbGVtZW50LCBDYXJkTnVtYmVyRWxlbWVudCwgQ2hlY2tvdXRQcm92aWRlciwgQ3VycmVuY3lTZWxlY3RvckVsZW1lbnQsIEVsZW1lbnRzLCBFbGVtZW50c0NvbnN1bWVyLCBFbWJlZGRlZENoZWNrb3V0LCBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXIsIEVwc0JhbmtFbGVtZW50LCBFeHByZXNzQ2hlY2tvdXRFbGVtZW50LCBGcHhCYW5rRWxlbWVudCwgSWJhbkVsZW1lbnQsIElkZWFsQmFua0VsZW1lbnQsIExpbmtBdXRoZW50aWNhdGlvbkVsZW1lbnQsIFAyNEJhbmtFbGVtZW50LCBQYXltZW50RWxlbWVudCwgUGF5bWVudE1ldGhvZE1lc3NhZ2luZ0VsZW1lbnQsIFBheW1lbnRSZXF1ZXN0QnV0dG9uRWxlbWVudCwgU2hpcHBpbmdBZGRyZXNzRWxlbWVudCwgdXNlQ2hlY2tvdXQsIHVzZUVsZW1lbnRzLCB1c2VTdHJpcGUgfTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIlByb3BUeXBlcyIsIm93bktleXMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQyIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImZvckVhY2giLCJrZXkiLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImRlZmluZVByb3BlcnR5IiwiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJ2YWx1ZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJleGNsdWRlZCIsInNvdXJjZUtleXMiLCJpbmRleE9mIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwic291cmNlU3ltYm9sS2V5cyIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiY2FsbCIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlUmVzdCIsIkFycmF5IiwiaXNBcnJheSIsIl9pIiwiX2FyciIsIl9uIiwiX2QiLCJfcyIsIl9lIiwibmV4dCIsImRvbmUiLCJlcnIiLCJvIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJuIiwidG9TdHJpbmciLCJzbGljZSIsIm5hbWUiLCJmcm9tIiwidGVzdCIsImxlbiIsImFycjIiLCJUeXBlRXJyb3IiLCJ1c2VBdHRhY2hFdmVudCIsImVsZW1lbnQiLCJldmVudCIsImNiIiwiY2JEZWZpbmVkIiwiY2JSZWYiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJjdXJyZW50IiwiZGVjb3JhdGVkQ2IiLCJvbiIsIm9mZiIsInVzZVByZXZpb3VzIiwicmVmIiwiaXNVbmtub3duT2JqZWN0IiwicmF3IiwiaXNQcm9taXNlIiwidGhlbiIsImlzU3RyaXBlIiwiZWxlbWVudHMiLCJjcmVhdGVUb2tlbiIsImNyZWF0ZVBheW1lbnRNZXRob2QiLCJjb25maXJtQ2FyZFBheW1lbnQiLCJQTEFJTl9PQkpFQ1RfU1RSIiwiaXNFcXVhbCIsImxlZnQiLCJyaWdodCIsImxlZnRBcnJheSIsInJpZ2h0QXJyYXkiLCJsZWZ0UGxhaW5PYmplY3QiLCJyaWdodFBsYWluT2JqZWN0IiwibGVmdEtleXMiLCJyaWdodEtleXMiLCJrZXlTZXQiLCJhbGxLZXlzIiwibCIsInIiLCJwcmVkIiwiZXZlcnkiLCJleHRyYWN0QWxsb3dlZE9wdGlvbnNVcGRhdGVzIiwib3B0aW9ucyIsInByZXZPcHRpb25zIiwiaW1tdXRhYmxlS2V5cyIsInJlZHVjZSIsIm5ld09wdGlvbnMiLCJpc1VwZGF0ZWQiLCJpbmNsdWRlcyIsImNvbnNvbGUiLCJ3YXJuIiwiY29uY2F0IiwiSU5WQUxJRF9TVFJJUEVfRVJST1IkMiIsInZhbGlkYXRlU3RyaXBlIiwibWF5YmVTdHJpcGUiLCJlcnJvck1zZyIsInVuZGVmaW5lZCIsIkVycm9yIiwicGFyc2VTdHJpcGVQcm9wIiwidGFnIiwic3RyaXBlUHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVzdWx0Iiwic3RyaXBlIiwicmVnaXN0ZXJXaXRoU3RyaXBlSnMiLCJfcmVnaXN0ZXJXcmFwcGVyIiwicmVnaXN0ZXJBcHBJbmZvIiwidmVyc2lvbiIsInVybCIsIkVsZW1lbnRzQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJkaXNwbGF5TmFtZSIsInBhcnNlRWxlbWVudHNDb250ZXh0IiwiY3R4IiwidXNlQ2FzZSIsIkVsZW1lbnRzIiwiX3JlZiIsInJhd1N0cmlwZVByb3AiLCJjaGlsZHJlbiIsInBhcnNlZCIsInVzZU1lbW8iLCJfUmVhY3QkdXNlU3RhdGUiLCJ1c2VTdGF0ZSIsIl9SZWFjdCR1c2VTdGF0ZTIiLCJzZXRDb250ZXh0IiwiaXNNb3VudGVkIiwic2FmZVNldENvbnRleHQiLCJwcmV2U3RyaXBlIiwidXBkYXRlcyIsInVwZGF0ZSIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsInByb3BUeXBlcyIsImFueSIsInVzZUVsZW1lbnRzQ29udGV4dFdpdGhVc2VDYXNlIiwidXNlQ2FzZU1lc3NhZ2UiLCJ1c2VDb250ZXh0IiwidXNlRWxlbWVudHMiLCJfdXNlRWxlbWVudHNDb250ZXh0V2kiLCJFbGVtZW50c0NvbnN1bWVyIiwiX3JlZjIiLCJmdW5jIiwiaXNSZXF1aXJlZCIsIl9leGNsdWRlZCQxIiwiQ2hlY2tvdXRTZGtDb250ZXh0IiwicGFyc2VDaGVja291dFNka0NvbnRleHQiLCJDaGVja291dENvbnRleHQiLCJleHRyYWN0Q2hlY2tvdXRDb250ZXh0VmFsdWUiLCJjaGVja291dFNkayIsInNlc3Npb25TdGF0ZSIsInNlc3Npb24iLCJhY3Rpb25zIiwiYXNzaWduIiwiSU5WQUxJRF9TVFJJUEVfRVJST1IkMSIsIkNoZWNrb3V0UHJvdmlkZXIiLCJzZXRTZXNzaW9uIiwiX1JlYWN0JHVzZVN0YXRlMyIsIl9SZWFjdCR1c2VTdGF0ZTQiLCJpbml0Q2hlY2tvdXRDYWxsZWRSZWYiLCJpbml0Q2hlY2tvdXQiLCJfcHJldk9wdGlvbnMkZWxlbWVudHMiLCJfb3B0aW9ucyRlbGVtZW50c09wdGkiLCJwcmV2aW91c0FwcGVhcmFuY2UiLCJlbGVtZW50c09wdGlvbnMiLCJhcHBlYXJhbmNlIiwiY3VycmVudEFwcGVhcmFuY2UiLCJjaGFuZ2VBcHBlYXJhbmNlIiwiY2hlY2tvdXRDb250ZXh0VmFsdWUiLCJzaGFwZSIsImZldGNoQ2xpZW50U2VjcmV0IiwidXNlQ2hlY2tvdXRTZGtDb250ZXh0V2l0aFVzZUNhc2UiLCJ1c2VDYXNlU3RyaW5nIiwidXNlRWxlbWVudHNPckNoZWNrb3V0U2RrQ29udGV4dFdpdGhVc2VDYXNlIiwiY2hlY2tvdXRTZGtDb250ZXh0IiwiZWxlbWVudHNDb250ZXh0IiwidXNlQ2hlY2tvdXQiLCJfZXhjbHVkZWQiLCJjYXBpdGFsaXplZCIsInN0ciIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwiY3JlYXRlRWxlbWVudENvbXBvbmVudCIsInR5cGUiLCJpc1NlcnZlciIsIkNsaWVudEVsZW1lbnQiLCJpZCIsImNsYXNzTmFtZSIsIl9yZWYkb3B0aW9ucyIsIm9uQmx1ciIsIm9uRm9jdXMiLCJvblJlYWR5Iiwib25DaGFuZ2UiLCJvbkVzY2FwZSIsIm9uQ2xpY2siLCJvbkxvYWRFcnJvciIsIm9uTG9hZGVyU3RhcnQiLCJvbk5ldHdvcmtzQ2hhbmdlIiwib25Db25maXJtIiwib25DYW5jZWwiLCJvblNoaXBwaW5nQWRkcmVzc0NoYW5nZSIsIm9uU2hpcHBpbmdSYXRlQ2hhbmdlIiwic2V0RWxlbWVudCIsImVsZW1lbnRSZWYiLCJkb21Ob2RlIiwicmVhZHlDYWxsYmFjayIsInVzZUxheW91dEVmZmVjdCIsIm5ld0VsZW1lbnQiLCJjcmVhdGVQYXltZW50RWxlbWVudCIsIm1vZGUiLCJyZXN0T3B0aW9ucyIsImNyZWF0ZVNoaXBwaW5nQWRkcmVzc0VsZW1lbnQiLCJjcmVhdGVCaWxsaW5nQWRkcmVzc0VsZW1lbnQiLCJjcmVhdGVFeHByZXNzQ2hlY2tvdXRFbGVtZW50IiwiY3JlYXRlQ3VycmVuY3lTZWxlY3RvckVsZW1lbnQiLCJjcmVhdGUiLCJtb3VudCIsImRlc3Ryb3kiLCJlcnJvciIsIlNlcnZlckVsZW1lbnQiLCJwcm9wcyIsIkVsZW1lbnQiLCJzdHJpbmciLCJfX2VsZW1lbnRUeXBlIiwiRW1iZWRkZWRDaGVja291dENvbnRleHQiLCJ1c2VFbWJlZGRlZENoZWNrb3V0Q29udGV4dCIsIklOVkFMSURfU1RSSVBFX0VSUk9SIiwiRW1iZWRkZWRDaGVja291dFByb3ZpZGVyIiwiZW1iZWRkZWRDaGVja291dFByb21pc2UiLCJsb2FkZWRTdHJpcGUiLCJlbWJlZGRlZENoZWNrb3V0Iiwic2V0U3RyaXBlQW5kSW5pdEVtYmVkZGVkQ2hlY2tvdXQiLCJpbml0RW1iZWRkZWRDaGVja291dCIsImNsaWVudFNlY3JldCIsIm9uQ29tcGxldGUiLCJvblNoaXBwaW5nRGV0YWlsc0NoYW5nZSIsIm9uTGluZUl0ZW1zQ2hhbmdlIiwiRW1iZWRkZWRDaGVja291dENsaWVudEVsZW1lbnQiLCJfdXNlRW1iZWRkZWRDaGVja291dEMiLCJ1bm1vdW50IiwiZSIsIkVtYmVkZGVkQ2hlY2tvdXRTZXJ2ZXJFbGVtZW50IiwiRW1iZWRkZWRDaGVja291dCIsInVzZVN0cmlwZSIsIl91c2VFbGVtZW50c09yQ2hlY2tvdSIsIkF1QmFua0FjY291bnRFbGVtZW50IiwiQ2FyZEVsZW1lbnQiLCJDYXJkTnVtYmVyRWxlbWVudCIsIkNhcmRFeHBpcnlFbGVtZW50IiwiQ2FyZEN2Y0VsZW1lbnQiLCJGcHhCYW5rRWxlbWVudCIsIkliYW5FbGVtZW50IiwiSWRlYWxCYW5rRWxlbWVudCIsIlAyNEJhbmtFbGVtZW50IiwiRXBzQmFua0VsZW1lbnQiLCJQYXltZW50RWxlbWVudCIsIkV4cHJlc3NDaGVja291dEVsZW1lbnQiLCJDdXJyZW5jeVNlbGVjdG9yRWxlbWVudCIsIlBheW1lbnRSZXF1ZXN0QnV0dG9uRWxlbWVudCIsIkxpbmtBdXRoZW50aWNhdGlvbkVsZW1lbnQiLCJBZGRyZXNzRWxlbWVudCIsIlNoaXBwaW5nQWRkcmVzc0VsZW1lbnQiLCJQYXltZW50TWV0aG9kTWVzc2FnaW5nRWxlbWVudCIsIkFmZmlybU1lc3NhZ2VFbGVtZW50IiwiQWZ0ZXJwYXlDbGVhcnBheU1lc3NhZ2VFbGVtZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/react-stripe-js/dist/react-stripe.esm.mjs\n");

/***/ })

};
;